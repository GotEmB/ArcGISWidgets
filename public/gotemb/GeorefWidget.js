// Generated by CoffeeScript 1.6.2
var extend;

extend = function(obj, mixin) {
  var method, name;

  for (name in mixin) {
    method = mixin[name];
    obj[name] = method;
  }
  return obj;
};

define(["dojo/_base/declare", "dijit/_WidgetBase", "dijit/_TemplatedMixin", "dijit/_WidgetsInTemplateMixin", "dojo/text!./GeorefWidget/templates/GeorefWidget.html", "dojo/_base/connect", "esri/layers/ArcGISImageServiceLayer", "esri/request", "esri/layers/MosaicRule", "esri/geometry/Polygon", "esri/tasks/GeometryService", "dojo/dom-style", "gotemb/GeorefWidget/PointGrid", "dojo/store/Observable", "dojo/store/Memory", "gotemb/GeorefWidget/TiepointsGrid", "esri/layers/GraphicsLayer", "dojo/_base/Color", "esri/symbols/SimpleMarkerSymbol", "esri/symbols/SimpleLineSymbol", "esri/graphic", "esri/geometry/Point", "dojox/form/FileInput", "dijit/form/Button", "dijit/layout/AccordionContainer", "dijit/layout/ContentPane", "gotemb/GeorefWidget/RastersGrid", "dijit/Dialog", "dijit/Toolbar", "dijit/ToolbarSeparator", "dijit/form/ToggleButton"], function(declare, _WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin, template, _arg, ArcGISImageServiceLayer, request, MosaicRule, Polygon, GeometryService, domStyle, PointGrid, Observable, Memory, TiepointsGrid, GraphicsLayer, Color, SimpleMarkerSymbol, SimpleLineSymbol, Graphic, Point) {
  var connect;

  connect = _arg.connect;
  return declare([_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin], {
    templateString: template,
    baseClass: "ClassifyWidget",
    map: null,
    imageFile: null,
    uploadForm: null,
    imageServiceUrl: "http://eg1109:6080/arcgis/rest/services/amberg_wgs/ImageServer",
    imageServiceLayer: null,
    referenceLayerUrl: "http://eg1109:6080/arcgis/rest/services/amberg_wgs_reference/ImageServer",
    referenceLayer: null,
    geometryServiceUrl: "http://lamborghini:6080/arcgis/rest/services/Utilities/Geometry/GeometryServer",
    geometryService: null,
    rastertype: null,
    currentId: null,
    rasters: null,
    rastersGrid: null,
    addRasterDialog: null,
    selectRasterContainer: null,
    tasksContainer: null,
    editTiepointsContainer: null,
    editTiepointsContainer_loading: null,
    tiepoints: null,
    tiepointsGrid: null,
    toggleTiepointsSelectionButton: null,
    tiepointsLayer: null,
    postCreate: function() {
      var _this = this;

      this.imageServiceLayer = new ArcGISImageServiceLayer(this.imageServiceUrl);
      this.geometryService = new GeometryService(this.geometryServiceUrl);
      return connect(this.imageServiceLayer, "onLoad", function() {
        _this.map.addLayer(_this.referenceLayer = new ArcGISImageServiceLayer(_this.referenceLayerUrl));
        _this.imageServiceLayer.setOpacity(0);
        _this.map.addLayer(_this.imageServiceLayer);
        _this.rastersGrid.set("columns", [
          {
            label: "Raster Id",
            field: "rasterId",
            sortable: false
          }, {
            label: "Name",
            field: "name",
            sortable: false
          }
        ]);
        _this.rastersGrid.set("selectionMode", "single");
        _this.loadRastersList();
        _this.rastersGrid.on("dgrid-select", function(_arg1) {
          var rows;

          rows = _arg1.rows;
          if (_this.currentId === rows[0].data.rasterId) {
            return;
          }
          _this.currentId = rows[0].data.rasterId;
          _this.imageServiceLayer.setMosaicRule(extend(new MosaicRule, {
            method: MosaicRule.METHOD_LOCKRASTER,
            lockRasterIds: [_this.currentId]
          }), true);
          return request({
            url: _this.imageServiceUrl + "/query",
            content: {
              objectIds: [_this.currentId],
              returnGeometry: true,
              outFields: "",
              f: "json"
            },
            handleAs: "json",
            load: function(response3) {
              _this.map.setExtent(new Polygon(response3.features[0].geometry).getExtent().expand(2));
              _this.imageServiceLayer.setOpacity(1);
              return domStyle.set(_this.tasksContainer.domNode, "display", "block");
            },
            error: console.error
          }, {
            usePost: true
          });
        });
        _this.tiepoints = new Observable(new Memory({
          idProperty: "id"
        }));
        _this.tiepointsGrid = new TiepointsGrid({
          columns: [
            {
              label: " ",
              field: "id",
              sortable: false
            }, {
              label: "Source Point",
              field: "sourcePoint",
              sortable: false,
              renderCell: function(object, value, domNode) {
                return new PointGrid({
                  x: value.x,
                  y: value.y,
                  onPointChanged: function(_arg1) {
                    var point, x, y;

                    x = _arg1.x, y = _arg1.y;
                    point = new Point(object.sourceGraphic.geometry);
                    point.x = value.x = x;
                    point.y = value.y = y;
                    return object.sourceGraphic.setGeometry(point);
                  }
                }).domNode;
              }
            }, {
              label: "Target Point",
              field: "targetPoint",
              sortable: false,
              renderCell: function(object, value, domNode) {
                return new PointGrid({
                  x: value.x,
                  y: value.y,
                  onPointChanged: function(_arg1) {
                    var point, x, y;

                    x = _arg1.x, y = _arg1.y;
                    point = new Point(object.targetGraphic.geometry);
                    point.x = value.x = x;
                    point.y = value.y = y;
                    return object.targetGraphic.setGeometry(point);
                  }
                }).domNode;
              }
            }
          ],
          store: _this.tiepoints,
          selectionMode: "none"
        }, _this.tiepointsGrid);
        _this.tiepointsGrid.startup();
        _this.tiepointsGrid.on(".field-id:click", function(e) {
          var row;

          if (_this.tiepointsGrid.isSelected(row = _this.tiepointsGrid.cell(e).row)) {
            return _this.tiepointsGrid.deselect(row);
          } else {
            return _this.tiepointsGrid.select(row);
          }
        });
        _this.tiepointsGrid.on("dgrid-select", function(_arg1) {
          var row, rows, _i, _len, _results;

          rows = _arg1.rows;
          _this.toggleTiepointsSelectionButton.set("label", "Clear Selection");
          _results = [];
          for (_i = 0, _len = rows.length; _i < _len; _i++) {
            row = rows[_i];
            row.data.sourceGraphic.show();
            _results.push(row.data.targetGraphic.show());
          }
          return _results;
        });
        _this.tiepointsGrid.on("dgrid-deselect", function(_arg1) {
          var bool, noneSelected, row, rowId, rows, _i, _len, _ref, _results;

          rows = _arg1.rows;
          _ref = _this.tiepointsGrid.selection;
          for (rowId in _ref) {
            bool = _ref[rowId];
            if (bool) {
              noneSelected = false;
            }
          }
          if (!((noneSelected != null) && !noneSelected)) {
            _this.toggleTiepointsSelectionButton.set("label", "Select All");
          }
          _results = [];
          for (_i = 0, _len = rows.length; _i < _len; _i++) {
            row = rows[_i];
            row.data.sourceGraphic.hide();
            _results.push(row.data.targetGraphic.hide());
          }
          return _results;
        });
        _this.tiepointsLayer = new GraphicsLayer;
        return _this.map.addLayer(_this.tiepointsLayer);
      });
    },
    loadRastersList: function(callback) {
      var _this = this;

      return request({
        url: this.imageServiceUrl + "/query",
        content: {
          f: "json",
          outFields: "OBJECTID, Name"
        },
        handlesAs: "json",
        load: function(response) {
          var feature;

          _this.rasters = (function() {
            var _i, _len, _ref, _results;

            _ref = response.features;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              feature = _ref[_i];
              _results.push({
                rasterId: feature.attributes.OBJECTID,
                name: feature.attributes.Name,
                spatialReference: feature.geometry.spatialReference
              });
            }
            return _results;
          })();
          _this.rastersGrid.refresh();
          _this.rastersGrid.renderArray(_this.rasters);
          return typeof callback === "function" ? callback() : void 0;
        },
        error: console.error
      }, {
        usePost: true
      });
    },
    showAddRasterDialog: function() {
      return this.addRasterDialog.show();
    },
    addRasterDialog_upload: function() {
      var _this = this;

      if (this.imageFile.value.length === 0) {
        return console.error("An image must be selected!");
      }
      this.rastertype = this.imageFile.value.indexOf("las") === -1 ? "Raster Dataset" : "HillshadedLAS";
      console.info("Step 1/3: Uploading...");
      return request({
        url: this.imageServiceUrl + "/uploads/upload",
        form: this.uploadForm,
        content: {
          f: "json"
        },
        handleAs: "json",
        timeout: 600000,
        load: function(response1) {
          if (!response1.success) {
            return console.error("Unsuccessful upload:\n" + response1);
          }
          console.info("Step 2/3: Uploaded, processing the image on server side...");
          return request({
            url: _this.imageServiceUrl + "/add",
            content: {
              itemIds: response1.item.itemID,
              rasterType: _this.rastertype,
              minimumCellSizeFactor: 0.1,
              maximumCellSizeFactor: 10,
              f: "json"
            },
            handleAs: "json",
            load: function(response2) {
              var id;

              if (id = response2.addResults[0].rasterId) {
                return _this.loadRastersList(function() {
                  _this.addRasterDialog.hide();
                  _this.rastersGrid.clearSelection();
                  if (_this.rasters.length > 0) {
                    return _this.rastersGrid.select(_this.rasters.length - 1);
                  }
                });
              }
            },
            error: console.error
          }, {
            usePost: true
          });
        },
        error: console.error
      }, {
        usePost: true
      });
    },
    roughTransform: function() {
      var _this = this;

      if (this.currentId == null) {
        return console.error("No raster selected");
      }
      return request({
        url: this.imageServiceUrl + ("/" + this.currentId + "/info"),
        content: {
          f: "json"
        },
        handleAs: "json",
        load: function(response1) {
          var src;

          src = response1.extent;
          return request({
            url: _this.imageServiceUrl + "/update",
            content: {
              f: "json",
              rasterId: _this.currentId,
              geodataTransforms: JSON.stringify([
                {
                  geodataTransform: "Polynomial",
                  geodataTransformArguments: {
                    sourcePoints: [
                      {
                        x: src.xmin,
                        y: src.ymin
                      }, {
                        x: src.xmin,
                        y: src.ymax
                      }, {
                        x: src.xmax,
                        y: src.ymin
                      }
                    ],
                    targetPoints: (function() {
                      var aspectRatio, dest, map;

                      aspectRatio = (src.xmax - src.xmin) / (src.ymax - src.ymin);
                      map = {
                        width: _this.map.extent.getWidth(),
                        height: _this.map.extent.getHeight(),
                        center: _this.map.extent.getCenter().toJson()
                      };
                      dest = {
                        width: Math.min(map.width, map.height * aspectRatio),
                        height: Math.min(map.height, map.width / aspectRatio)
                      };
                      dest.xmin = map.center.x - dest.width / 2;
                      dest.xmax = map.center.x + dest.width / 2;
                      dest.ymin = map.center.y - dest.height / 2;
                      dest.ymax = map.center.y + dest.height / 2;
                      return [
                        {
                          x: dest.xmin,
                          y: dest.ymin
                        }, {
                          x: dest.xmin,
                          y: dest.ymax
                        }, {
                          x: dest.xmax,
                          y: dest.ymin
                        }
                      ];
                    })(),
                    polynomialOrder: 1,
                    spatialReference: src.spatialReference
                  }
                }
              ])
            },
            handleAs: "json",
            load: function() {
              return request({
                url: _this.imageServiceUrl + "/query",
                content: {
                  objectIds: _this.currentId,
                  returnGeometry: true,
                  outFields: "",
                  f: "json"
                },
                handleAs: "json",
                load: function(response3) {
                  return _this.map.setExtent(new Polygon(response3.features[0].geometry).getExtent().expand(2));
                },
                error: console.error
              }, {
                usePost: true
              });
            },
            error: console.error
          }, {
            usePost: true
          });
        },
        error: console.error
      }, {
        usePost: true
      });
    },
    computeAndTransform: function() {
      var _this = this;

      return this.computeTiePoints(function(_arg1) {
        var point, tiePoints;

        tiePoints = _arg1.tiePoints;
        return request({
          url: _this.imageServiceUrl + "/update",
          content: {
            f: "json",
            rasterId: _this.currentId,
            geodataTransforms: JSON.stringify([
              {
                geodataTransform: "Polynomial",
                geodataTransformArguments: {
                  sourcePoints: (function() {
                    var _i, _len, _ref, _results;

                    _ref = tiePoints.sourcePoints;
                    _results = [];
                    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                      point = _ref[_i];
                      _results.push({
                        x: point.x,
                        y: point.y
                      });
                    }
                    return _results;
                  })(),
                  targetPoints: (function() {
                    var _i, _len, _ref, _results;

                    _ref = tiePoints.targetPoints;
                    _results = [];
                    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                      point = _ref[_i];
                      _results.push({
                        x: point.x,
                        y: point.y
                      });
                    }
                    return _results;
                  })(),
                  polynomialOrder: 1,
                  spatialReference: tiePoints.sourcePoints[0].spatialReference
                }
              }
            ])
          },
          handleAs: "json",
          load: function() {
            return request({
              url: _this.imageServiceUrl + "/query",
              content: {
                objectIds: _this.currentId,
                returnGeometry: true,
                outFields: "",
                f: "json"
              },
              handleAs: "json",
              load: function(response2) {
                return _this.map.setExtent(new Polygon(response2.features[0].geometry).getExtent().expand(2));
              },
              error: console.error
            });
          },
          error: console.error
        }, {
          usePost: true
        });
      });
    },
    computeTiePoints: function(callback) {
      var _this = this;

      if (this.currentId == null) {
        return console.error("No raster selected");
      }
      return request({
        url: "dummyResponses/tiepoints1.json",
        content: {
          f: "json",
          rasterId: this.currentId,
          geodataTransforms: JSON.stringify([
            {
              geodataTransform: "Identity",
              geodataTransformArguments: {
                spatialReference: this.rasters.filter(function(x) {
                  return x.rasterId === _this.currentId;
                })[0].spatialReference
              }
            }
          ])
        },
        handleAs: "json",
        load: function(response) {
          return typeof callback === "function" ? callback(response) : void 0;
        },
        error: console.error
      });
    },
    toggleReferenceLayer: function(state) {
      return this.referenceLayer.setOpacity(state ? 1 : 0);
    },
    startEditTiepoints: function() {
      var container, containers, display, _i, _len, _ref,
        _this = this;

      domStyle.set(this.editTiepointsContainer_loading, "display", "block");
      _ref = {
        none: [this.selectRasterContainer, this.tasksContainer],
        block: [this.editTiepointsContainer]
      };
      for (display in _ref) {
        containers = _ref[display];
        for (_i = 0, _len = containers.length; _i < _len; _i++) {
          container = containers[_i];
          domStyle.set(container.domNode, "display", display);
        }
      }
      return this.computeTiePoints(function(_arg1) {
        var i, sourceGraphic, sourceSymbol, targetGraphic, targetSymbol, tiePoints, _j, _ref1;

        tiePoints = _arg1.tiePoints;
        domStyle.set(_this.editTiepointsContainer_loading, "display", "none");
        sourceSymbol = new SimpleMarkerSymbol(SimpleMarkerSymbol.STYLE_X, 10, new SimpleLineSymbol(SimpleLineSymbol.STYLE_SOLID, new Color([20, 20, 180]), 2), new Color([0, 0, 0]));
        targetSymbol = new SimpleMarkerSymbol(SimpleMarkerSymbol.STYLE_X, 10, new SimpleLineSymbol(SimpleLineSymbol.STYLE_SOLID, new Color([180, 20, 20]), 2), new Color([0, 0, 0]));
        for (i = _j = 0, _ref1 = tiePoints.sourcePoints.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
          _this.tiepoints.put({
            id: i + 1,
            sourcePoint: {
              x: tiePoints.sourcePoints[i].x,
              y: tiePoints.sourcePoints[i].y
            },
            targetPoint: {
              x: tiePoints.targetPoints[i].x,
              y: tiePoints.targetPoints[i].y
            },
            sourceGraphic: sourceGraphic = new Graphic(new Point(tiePoints.sourcePoints[i]), sourceSymbol),
            targetGraphic: targetGraphic = new Graphic(new Point(tiePoints.targetPoints[i]), targetSymbol)
          });
          _this.tiepointsLayer.add(sourceGraphic);
          _this.tiepointsLayer.add(targetGraphic);
        }
        return _this.tiepointsGrid.selectAll();
      });
    },
    closeEditTiepoints: function() {
      var container, containers, display, tiepoint, _i, _len, _ref, _ref1, _results;

      domStyle.set(this.editTiepointsContainer_loading, "display", "none");
      this.tiepointsLayer.clear();
      _ref = this.tiepoints.data.splice(0);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        tiepoint = _ref[_i];
        this.tiepoints.remove(tiepoint.id);
      }
      _ref1 = {
        block: [this.selectRasterContainer, this.tasksContainer],
        none: [this.editTiepointsContainer]
      };
      _results = [];
      for (display in _ref1) {
        containers = _ref1[display];
        _results.push((function() {
          var _j, _len1, _results1;

          _results1 = [];
          for (_j = 0, _len1 = containers.length; _j < _len1; _j++) {
            container = containers[_j];
            _results1.push(domStyle.set(container.domNode, "display", display));
          }
          return _results1;
        })());
      }
      return _results;
    },
    toggleTiepointsSelection: function() {
      if (this.toggleTiepointsSelectionButton.label === "Clear Selection") {
        return this.tiepointsGrid.clearSelection();
      } else {
        return this.tiepointsGrid.selectAll();
      }
    }
  });
});

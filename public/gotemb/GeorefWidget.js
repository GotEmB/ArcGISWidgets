// Generated by CoffeeScript 1.6.2
(function() {
  var extend;

  extend = function(obj, mixin) {
    var method, name;

    for (name in mixin) {
      method = mixin[name];
      obj[name] = method;
    }
    return obj;
  };
  return define(["dojo/_base/declare", "dijit/_WidgetBase", "dijit/_TemplatedMixin", "dijit/_WidgetsInTemplateMixin", "dojo/text!./GeorefWidget/templates/GeorefWidget.html", "dojo/_base/connect", "esri/layers/ArcGISImageServiceLayer", "esri/request", "esri/layers/MosaicRule", "esri/geometry/Polygon", "esri/tasks/GeometryService", "dojo/dom-style", "gotemb/GeorefWidget/PointGrid", "dojo/store/Observable", "dojo/store/Memory", "gotemb/GeorefWidget/TiepointsGrid", "esri/layers/GraphicsLayer", "dojo/_base/Color", "esri/symbols/SimpleMarkerSymbol", "esri/symbols/SimpleLineSymbol", "esri/graphic", "esri/geometry/Point", "dojo/window", "dojo/dom-class", "dojo/query", "dgrid/editor", "gotemb/GeorefWidget/RastersGrid", "esri/geometry/Extent", "esri/tasks/ProjectParameters", "esri/SpatialReference", "dojo/_base/url", "esri/layers/ArcGISTiledMapServiceLayer", "gotemb/GeorefWidget/AsyncResultsGrid", "dijit/popup", "dijit/form/CheckBox", "dojo/aspect", "esri/layers/ImageServiceParameters", "esri/layers/RasterFunction", "dojox/form/FileInput", "dijit/form/Button", "dijit/form/DropDownButton", "dijit/layout/AccordionContainer", "dijit/layout/ContentPane", "dijit/Dialog", "dijit/Toolbar", "dijit/ToolbarSeparator", "dijit/form/ToggleButton", "dijit/Menu", "dijit/MenuItem", "dijit/CheckedMenuItem", "dojo/NodeList-traverse", "dojo/NodeList-dom", "dijit/TooltipDialog"], function(declare, _WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin, template, _arg, ArcGISImageServiceLayer, request, MosaicRule, Polygon, GeometryService, domStyle, PointGrid, Observable, Memory, TiepointsGrid, GraphicsLayer, Color, SimpleMarkerSymbol, SimpleLineSymbol, Graphic, Point, win, domClass, query, editor, RastersGrid, Extent, ProjectParameters, SpatialReference, Url, ArcGISTiledMapServiceLayer, AsyncResultsGrid, popup, CheckBox, aspect, ImageServiceParameters, RasterFunction) {
    var connect, disconnect;

    connect = _arg.connect, disconnect = _arg.disconnect;
    return declare([_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin], {
      templateString: template,
      baseClass: "GeorefWidget",
      map: null,
      imageFile: null,
      uploadForm: null,
      imageServiceUrl: "http://eg1109.uae.esri.com:6080/arcgis/rest/services/ISERV/ImageServer",
      imageServiceLayer: null,
      geometryServiceUrl: "http://tasks.arcgisonline.com/arcgis/rest/services/Geometry/GeometryServer",
      geometryService: null,
      rastertype: null,
      currentId: null,
      rasters: null,
      rastersGrid: null,
      addRasterDialog: null,
      selectRasterContainer: null,
      tasksContainer: null,
      editTiepointsContainer: null,
      tiepoints: null,
      tiepointsGrid: null,
      toggleTiepointsSelectionMenuItem: null,
      tiepointsLayer: null,
      tiepointsContextMenu: null,
      resetTiepointMenuItem: null,
      mouseTip: null,
      addTiepointButton: null,
      removeSelectedTiepointsMenuItem: null,
      resetSelectedTiepointsMenuItem: null,
      manualTransformContainer: null,
      rtMoveContainer: null,
      rtMoveFromGrid: null,
      rtMoveToGrid: null,
      rt_moveButton: null,
      rt_scaleButton: null,
      rt_rotateButton: null,
      rtMoveFromPickButton: null,
      rtMoveToPickButton: null,
      miscGraphicsLayer: null,
      rtScaleContainer: null,
      rtScaleFactorInput: null,
      rtRotateContainer: null,
      rtRotateDegreesInput: null,
      rasterNotSelectedDialog: null,
      selectBasemap_SatelliteButton: null,
      selectBasemap_HybridButton: null,
      selectBasemap_TopographicButton: null,
      selectBasemap_StreetsButton: null,
      selectBasemap_NaturalVueButton: null,
      naturalVueServiceUrl: "http://raster.arcgisonline.com/ArcGIS/rest/services/MDA_NaturalVue_Imagery_cached/MapServer",
      naturalVueServiceLayer: null,
      asyncResultsContainer: null,
      asyncResults: null,
      asyncResultsGrid: null,
      asyncTaskDetailsPopup: null,
      atdpResultId: null,
      atdpTask: null,
      atdpRasterId: null,
      atdpStatus: null,
      atdpStartTime: null,
      atdpEndTime: null,
      atdpContinueEvent: null,
      atdpContinueButton: null,
      confirmActionPopup: null,
      confirmActionPopupContinueEvent: null,
      collectComputedTiepointsButton: null,
      computeAndTransformButton: null,
      loadingGif: null,
      toggleRasterLayerButton: null,
      setImageFormat_JPGPNGButton: null,
      setImageFormat_JPGButton: null,
      rastersDisplayMenu: null,
      sourceSymbol: new SimpleMarkerSymbol(SimpleMarkerSymbol.STYLE_X, 10, new SimpleLineSymbol(SimpleLineSymbol.STYLE_SOLID, new Color([20, 20, 180]), 2), new Color([0, 0, 0])),
      targetSymbol: new SimpleMarkerSymbol(SimpleMarkerSymbol.STYLE_X, 10, new SimpleLineSymbol(SimpleLineSymbol.STYLE_SOLID, new Color([180, 20, 20]), 2), new Color([0, 0, 0])),
      selectedSourceSymbol: new SimpleMarkerSymbol(SimpleMarkerSymbol.STYLE_X, 16, new SimpleLineSymbol(SimpleLineSymbol.STYLE_SOLID, new Color([20, 20, 180]), 3), new Color([0, 0, 0])),
      selectedTargetSymbol: new SimpleMarkerSymbol(SimpleMarkerSymbol.STYLE_X, 16, new SimpleLineSymbol(SimpleLineSymbol.STYLE_SOLID, new Color([180, 20, 20]), 3), new Color([0, 0, 0])),
      scrollToElement: function(element) {
        var elemNL, prevNL;

        elemNL = query(element).closest(".dgrid-row");
        if ((prevNL = elemNL.prev()).length === 0 || prevNL[0].classList.contains("dgrid-preload")) {
          elemNL.parent().parent()[0].scrollTop = 0;
        } else {
          win.scrollIntoView(prevNL[0]);
        }
        return win.scrollIntoView(element);
      },
      postCreate: function() {
        var corsEnabledServers, imageServiceAuthority, onceDone,
          _this = this;

        imageServiceAuthority = new Url(this.imageServiceUrl).authority;
        corsEnabledServers = esri.config.defaults.io.corsEnabledServers;
        if (!corsEnabledServers.some(function(x) {
          return x === imageServiceAuthority;
        })) {
          corsEnabledServers.push(imageServiceAuthority);
        }
        this.imageServiceLayer = new ArcGISImageServiceLayer(this.imageServiceUrl, {
          imageServiceParameters: extend(new ImageServiceParameters, {
            renderingRule: extend(new RasterFunction, {
              functionName: "Stretch",
              "arguments": {
                StretchType: 6,
                DRA: true,
                MinPercent: 0,
                MaxPercent: 2
              },
              variableName: "Raster"
            })
          })
        });
        this.geometryService = new GeometryService(this.geometryServiceUrl);
        onceDone = false;
        return this.watch("map", function(attr, oldMap, newMap) {
          if (onceDone) {
            return;
          } else {
            onceDone = true;
          }
          _this.map.addLayer(_this.imageServiceLayer);
          _this.rasters = new Observable(new Memory({
            idProperty: "rasterId"
          }));
          _this.rastersGrid = new RastersGrid({
            columns: [
              editor({
                label: " ",
                field: "display",
                editor: CheckBox,
                editorArgs: {
                  title: "Toggle Visibility"
                },
                sortable: false
              }), {
                label: "Id",
                field: "rasterId",
                sortable: false
              }, {
                label: "Name",
                field: "name",
                sortable: false
              }
            ],
            store: _this.rasters,
            selectionMode: "none"
          }, _this.rastersGrid);
          _this.rastersGrid.startup();
          domStyle.set(_this.selectRasterContainer.domNode, "display", "block");
          _this.loadRastersList(function() {
            return _this.refreshMosaicRule();
          });
          _this.rastersGrid.on(".field-rasterId:click, .field-name:click", function(e) {
            _this.rastersGrid.clearSelection();
            return _this.rastersGrid.select(_this.rastersGrid.cell(e).row);
          });
          _this.rastersGrid.on("dgrid-select", function(_arg1) {
            var rows;

            rows = _arg1.rows;
            _this.currentId = rows[0].data.rasterId;
            _this.scrollToElement(rows[0].element);
            return request({
              url: _this.imageServiceUrl + "/query",
              content: {
                objectIds: [_this.currentId],
                returnGeometry: true,
                outFields: "",
                f: "json"
              },
              handleAs: "json",
              load: function(response3) {
                return _this.map.setExtent(new Polygon(response3.features[0].geometry).getExtent());
              },
              error: function(_arg2) {
                var message;

                message = _arg2.message;
                return console.error(message);
              }
            }, {
              usePost: true
            });
          });
          _this.rastersGrid.on("dgrid-datachange", function(_arg1) {
            var cell, value;

            cell = _arg1.cell, value = _arg1.value;
            cell.row.data.display = value;
            return _this.refreshMosaicRule();
          });
          _this.tiepoints = new Observable(new Memory({
            idProperty: "id"
          }));
          _this.tiepointsGrid = new TiepointsGrid({
            columns: [
              {
                label: " ",
                field: "id",
                sortable: false
              }, {
                label: "Source Point",
                field: "sourcePoint",
                sortable: false,
                renderCell: function(object, value, domNode) {
                  var pointGrid;

                  pointGrid = new PointGrid({
                    x: value.geometry.x,
                    y: value.geometry.y,
                    onPointChanged: function(_arg1) {
                      var point, x, y;

                      x = _arg1.x, y = _arg1.y;
                      point = new Point(value.geometry);
                      point.x = x;
                      point.y = y;
                      return value.setGeometry(point);
                    }
                  });
                  value.pointChanged = function() {
                    return pointGrid.setPoint({
                      x: value.geometry.x,
                      y: value.geometry.y
                    });
                  };
                  value.gotoPointGrid = function() {
                    var mouseUpEvent, rowNL;

                    _this.scrollToElement(pointGrid.domNode);
                    rowNL = query(pointGrid.domNode).closest(".dgrid-row");
                    rowNL.addClass("yellow");
                    return mouseUpEvent = connect(_this.tiepointsLayer, "onMouseUp", function() {
                      rowNL.removeClass("yellow");
                      return disconnect(mouseUpEvent);
                    });
                  };
                  return pointGrid.domNode;
                }
              }, {
                label: "Target Point",
                field: "targetPoint",
                sortable: false,
                renderCell: function(object, value, domNode) {
                  var pointGrid;

                  pointGrid = new PointGrid({
                    x: value.geometry.x,
                    y: value.geometry.y,
                    onPointChanged: function(_arg1) {
                      var point, x, y;

                      x = _arg1.x, y = _arg1.y;
                      point = new Point(value.geometry);
                      point.x = x;
                      point.y = y;
                      return value.setGeometry(point);
                    }
                  });
                  value.pointChanged = function() {
                    return pointGrid.setPoint({
                      x: value.geometry.x,
                      y: value.geometry.y
                    });
                  };
                  value.gotoPointGrid = function() {
                    var mouseUpEvent, rowNL;

                    _this.scrollToElement(pointGrid.domNode);
                    rowNL = query(pointGrid.domNode).closest(".dgrid-row");
                    rowNL.addClass("yellow");
                    return mouseUpEvent = connect(_this.tiepointsLayer, "onMouseUp", function() {
                      rowNL.removeClass("yellow");
                      return disconnect(mouseUpEvent);
                    });
                  };
                  return pointGrid.domNode;
                }
              }
            ],
            store: _this.tiepoints
          }, _this.tiepointsGrid);
          _this.tiepointsGrid.startup();
          _this.tiepointsGrid.on("dgrid-select", function(_arg1) {
            var row, rows, _i, _len, _results;

            rows = _arg1.rows;
            _this.toggleTiepointsSelectionMenuItem.set("label", "Clear Selection");
            domStyle.set(_this.removeSelectedTiepointsMenuItem.domNode, "display", "table-row");
            _results = [];
            for (_i = 0, _len = rows.length; _i < _len; _i++) {
              row = rows[_i];
              if (row.data.original != null) {
                domStyle.set(_this.resetSelectedTiepointsMenuItem.domNode, "display", "table-row");
              }
              row.data.sourcePoint.setSymbol(_this.selectedSourceSymbol);
              _results.push(row.data.targetPoint.setSymbol(_this.selectedTargetSymbol));
            }
            return _results;
          });
          _this.tiepointsGrid.on("dgrid-deselect", function(_arg1) {
            var bool, noneSelected, row, rowId, rows, showReset, _i, _len, _ref, _results;

            rows = _arg1.rows;
            _ref = _this.tiepointsGrid.selection;
            for (rowId in _ref) {
              bool = _ref[rowId];
              if (!(bool)) {
                continue;
              }
              noneSelected = false;
              if (_this.tiepointsGrid.row(rowId).data.original != null) {
                showReset = true;
              }
            }
            if (!((noneSelected != null) && !noneSelected)) {
              _this.toggleTiepointsSelectionMenuItem.set("label", "Select All");
              domStyle.set(_this.removeSelectedTiepointsMenuItem.domNode, "display", "none");
            }
            if (!showReset) {
              domStyle.set(_this.resetSelectedTiepointsMenuItem.domNode, "display", "none");
            }
            _results = [];
            for (_i = 0, _len = rows.length; _i < _len; _i++) {
              row = rows[_i];
              row.data.sourcePoint.setSymbol(_this.sourceSymbol);
              _results.push(row.data.targetPoint.setSymbol(_this.targetSymbol));
            }
            return _results;
          });
          _this.tiepointsLayer = new GraphicsLayer;
          _this.map.addLayer(_this.tiepointsLayer);
          _this.miscGraphicsLayer = new GraphicsLayer;
          _this.map.addLayer(_this.miscGraphicsLayer);
          connect(_this.tiepointsLayer, "onMouseDown", function(e) {
            var _base;

            _this.map.disablePan();
            _this.graphicBeingMoved = e.graphic;
            return typeof (_base = _this.graphicBeingMoved).gotoPointGrid === "function" ? _base.gotoPointGrid() : void 0;
          });
          connect(_this.tiepointsLayer, "onClick onDblClick", function(e) {
            delete _this.graphicBeingMoved;
            return _this.map.enablePan();
          });
          connect(_this.miscGraphicsLayer, "onMouseDown", function(e) {
            _this.map.disablePan();
            return _this.graphicBeingMoved = e.graphic;
          });
          connect(_this.miscGraphicsLayer, "onClick onDblClick", function(e) {
            delete _this.graphicBeingMoved;
            return _this.map.enablePan();
          });
          connect(_this.map, "onMouseDrag", function(e) {
            var _base;

            if (_this.graphicBeingMoved == null) {
              return;
            }
            _this.graphicBeingMoved.setGeometry(e.mapPoint);
            return typeof (_base = _this.graphicBeingMoved).pointChanged === "function" ? _base.pointChanged() : void 0;
          });
          connect(_this.map, "onMouseDragEnd", function(e) {
            var _base;

            if (_this.graphicBeingMoved == null) {
              return;
            }
            _this.graphicBeingMoved.setGeometry(e.mapPoint);
            if (typeof (_base = _this.graphicBeingMoved).pointChanged === "function") {
              _base.pointChanged();
            }
            delete _this.graphicBeingMoved;
            return _this.map.enablePan();
          });
          connect(_this.map, "onClick", function(e) {
            var rec, row, rtc;

            if (domStyle.get(_this.selectRasterContainer.domNode, "display") !== "block") {
              return;
            }
            domStyle.set(_this.loadingGif, "display", "block");
            rtc = (function() {
              var _i, _len, _ref, _results;

              _ref = this.rasters.data;
              _results = [];
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                row = _ref[_i];
                if (row.display) {
                  _results.push(row);
                }
              }
              return _results;
            }).call(_this);
            return (rec = function() {
              if (rtc.length === 0) {
                return domStyle.set(_this.loadingGif, "display", "none");
              }
              row = rtc.pop();
              return request({
                url: _this.imageServiceUrl + "/query",
                content: {
                  objectIds: row.rasterId,
                  returnGeometry: true,
                  outFields: "",
                  f: "json"
                },
                handleAs: "json",
                load: function(response) {
                  var updateEvent;

                  if (new Polygon(response.features[0].geometry).contains(e.mapPoint)) {
                    _this.rastersGrid.clearSelection();
                    _this.rastersGrid.select(row);
                    return updateEvent = connect(_this.imageServiceLayer, "onUpdateEnd", function() {
                      disconnect(updateEvent);
                      return domStyle.set(_this.loadingGif, "display", "none");
                    });
                  } else {
                    return rec();
                  }
                },
                error: function(_arg1) {
                  var message;

                  message = _arg1.message;
                  return console.error(message);
                }
              }, {
                usePost: true
              });
            })();
          });
          _this.asyncResults = new Observable(new Memory({
            idProperty: "resultId"
          }));
          _this.asyncResultsGrid = new AsyncResultsGrid({
            columns: [
              {
                label: "Id",
                field: "resultId",
                sortable: false
              }, {
                label: "Task",
                field: "task",
                sortable: false
              }, {
                label: "Status",
                field: "status",
                sortable: false
              }
            ],
            store: _this.asyncResults,
            selectionMode: "none"
          }, _this.asyncResultsGrid);
          _this.asyncResultsGrid.startup();
          _this.asyncResultsGrid.on(".field-resultId:click, .field-task:click, .field-status:click", function(e) {
            _this.asyncResultsGrid.clearSelection();
            return _this.asyncResultsGrid.select(_this.asyncResultsGrid.cell(e).row);
          });
          _this.asyncResultsGrid.on("dgrid-select", function(_arg1) {
            var label, row, value, _ref, _ref1, _ref2;

            row = _arg1.rows[0];
            _ref = {
              atdpResultId: "resultId",
              atdpTask: "task",
              atdpStatus: "status",
              atdpRasterId: "rasterId",
              atdpStartTime: "startTime",
              atdpEndTime: "endTime"
            };
            for (label in _ref) {
              value = _ref[label];
              _this[label].innerHTML = (_ref1 = row.data[value]) != null ? _ref1 : "--";
            }
            domStyle.set(_this.atdpContinueButton.domNode, "display", row.data.callback != null ? "inline-block" : "none");
            domStyle.set(_this.atdpRemoveButton.domNode, "display", row.data.status === "Pending" ? "none" : "block");
            _this.atdpContinueButton.set("label", (_ref2 = row.data.callbackLabel) != null ? _ref2 : "Continue Task");
            _this.atdpContinueEvent = function() {
              var atdpOnceDone, selectAspect, _base;

              _this.atdpClose();
              if (row.data.rasterId != null) {
                _this.rastersGrid.clearSelection();
                _this.rastersGrid.select(_this.rastersGrid.row(row.data.rasterId));
                atdpOnceDone = false;
                return selectAspect = aspect.after(_this.rastersGrid.on("dgrid-select", function() {
                  var _base;

                  if (atdpOnceDone) {
                    return;
                  } else {
                    atdpOnceDone = true;
                  }
                  selectAspect.remove();
                  return typeof (_base = row.data).callback === "function" ? _base.callback() : void 0;
                }));
              } else {
                return typeof (_base = row.data).callback === "function" ? _base.callback() : void 0;
              }
            };
            popup.open({
              popup: _this.asyncTaskDetailsPopup,
              around: row.element,
              orient: ["above", "below"]
            });
            return _this.asyncTaskDetailsPopup.focus();
          });
          window.self = _this;
          return connect(document, "onkeydown", function(e) {
            if (document.activeElement.tagName.toLowerCase() === "input" && document.activeElement.type.toLowerCase() === "text") {
              return;
            }
            if (e.which === 82) {
              return _this.toggleRasterLayerButton.set("checked", !_this.toggleRasterLayerButton.checked);
            }
          });
        });
      },
      refreshMosaicRule: function(callback) {
        var raster, updateEvent,
          _this = this;

        this.imageServiceLayer.setMosaicRule(extend(new MosaicRule, {
          method: MosaicRule.METHOD_LOCKRASTER,
          lockRasterIds: (function() {
            var _i, _len, _ref, _results;

            if (domStyle.get(this.selectRasterContainer.domNode, "display") === "block" || (this.currentId == null)) {
              this.imageServiceLayer.setVisibility(((function() {
                var _i, _len, _ref, _results;

                _ref = this.rasters.data;
                _results = [];
                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                  raster = _ref[_i];
                  if (raster.display) {
                    _results.push(raster);
                  }
                }
                return _results;
              }).call(this)).length > 0);
              _ref = this.rasters.data;
              _results = [];
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                raster = _ref[_i];
                if (raster.display) {
                  _results.push(raster.rasterId);
                }
              }
              return _results;
            } else {
              this.imageServiceLayer.setVisibility(true);
              return [this.currentId];
            }
          }).call(this)
        }));
        if (!(domStyle.get(this.selectRasterContainer.domNode, "display") === "block" || (this.currentId == null)) || ((function() {
          var _i, _len, _ref, _results;

          _ref = this.rasters.data;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            raster = _ref[_i];
            if (raster.display) {
              _results.push(raster);
            }
          }
          return _results;
        }).call(this)).length > 0) {
          domStyle.set(this.loadingGif, "display", "block");
          return updateEvent = connect(this.imageServiceLayer, "onUpdateEnd", function() {
            disconnect(updateEvent);
            domStyle.set(_this.loadingGif, "display", "none");
            return typeof callback === "function" ? callback() : void 0;
          });
        }
      },
      loadRastersList: function(callback) {
        var _this = this;

        return request({
          url: this.imageServiceUrl + "/query",
          content: {
            f: "json",
            outFields: "OBJECTID, Name"
          },
          handlesAs: "json",
          load: function(response) {
            var feature, _i, _len, _ref;

            _ref = response.features;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              feature = _ref[_i];
              if (feature.attributes.Name !== "World_Imagery") {
                _this.rasters.put({
                  rasterId: feature.attributes.OBJECTID,
                  name: feature.attributes.Name,
                  spatialReference: new SpatialReference(feature.geometry.spatialReference),
                  display: true
                });
              }
            }
            if (typeof callback === "function") {
              callback();
            }
            return domStyle.set(_this.loadingGif, "display", "none");
          },
          error: function(_arg1) {
            var message;

            message = _arg1.message;
            console.error(message);
            return console.log(esri.config.defaults.io.corsEnabledServers);
          }
        }, {
          usePost: true
        });
      },
      showAddRasterDialog: function() {
        return this.addRasterDialog.show();
      },
      addRasterDialog_upload: function() {
        var asyncTask,
          _this = this;

        if (this.imageFile.value.length === 0) {
          return console.error("An image must be selected!");
        }
        this.rastertype = "Raster Dataset";
        this.asyncResults.put(asyncTask = {
          resultId: (Math.max.apply(Math, this.asyncResults.data.map(function(x) {
            return x.resultId;
          }).concat(0))) + 1,
          task: "Add Raster",
          status: "Pending",
          startTime: (new Date).toLocaleString()
        });
        if (domStyle.get(this.selectRasterContainer.domNode, "display") === "block") {
          domStyle.set(this.asyncResultsContainer.domNode, "display", "block");
        }
        this.addRasterDialog.hide().then(function() {
          return _this.asyncResultsGrid.select(asyncTask);
        });
        return request({
          url: this.imageServiceUrl + "/uploads/upload",
          form: this.uploadForm,
          content: {
            f: "json"
          },
          handleAs: "json",
          timeout: 600000,
          load: function(response1) {
            if (!response1.success) {
              extend(asyncTask, {
                status: "Failed",
                endTime: (new Date).toLocaleString()
              });
              return _this.asyncResults.notify(asyncTask, asyncTask.resultId);
            }
            if (!response1.success) {
              return console.error("Unsuccessful upload:\n" + response1);
            }
            console.info("Step 2/3: Uploaded, processing the image on server side...");
            return request({
              url: _this.imageServiceUrl + "/add",
              content: {
                itemIds: response1.item.itemID,
                rasterType: _this.rastertype,
                minimumCellSizeFactor: 0.1,
                maximumCellSizeFactor: 10,
                f: "json"
              },
              handleAs: "json",
              load: function(response2) {
                var id;

                if (!(id = response2.addResults[0].rasterId)) {
                  extend(asyncTask, {
                    status: "Failed",
                    endTime: (new Date).toLocaleString()
                  });
                  return _this.asyncResults.notify(asyncTask, asyncTask.resultId);
                }
                _this.asyncResults.notify(asyncTask, asyncTask.resultId);
                return _this.loadRastersList(function() {
                  extend(asyncTask, {
                    rasterId: id,
                    status: "Completed",
                    endTime: (new Date).toLocaleString(),
                    callback: function() {},
                    callbackLabel: "View Raster"
                  });
                  return _this.asyncResults.notify(asyncTask, asyncTask.resultId);
                });
              },
              error: function(_arg1) {
                var message;

                message = _arg1.message;
                extend(asyncTask, {
                  status: "Failed",
                  endTime: (new Date).toLocaleString()
                });
                _this.asyncResults.notify(asyncTask, asyncTask.resultId);
                return console.error(message);
              }
            }, {
              usePost: true
            });
          },
          error: function(_arg1) {
            var message;

            message = _arg1.message;
            extend(asyncTask, {
              status: "Failed",
              endTime: (new Date).toLocaleString()
            });
            _this.asyncResults.notify(asyncTask, asyncTask.resultId);
            return console.error(message);
          }
        }, {
          usePost: true
        });
      },
      applyTransform: function(_arg1, callback) {
        var gotoLocation, point, tiePoints,
          _this = this;

        tiePoints = _arg1.tiePoints, gotoLocation = _arg1.gotoLocation;
        if (gotoLocation == null) {
          gotoLocation = true;
        }
        return request({
          url: this.imageServiceUrl + "/update",
          content: {
            f: "json",
            rasterId: this.currentId,
            geodataTransforms: JSON.stringify([
              {
                geodataTransform: "Polynomial",
                geodataTransformArguments: {
                  sourcePoints: (function() {
                    var _i, _len, _ref, _results;

                    _ref = tiePoints.sourcePoints;
                    _results = [];
                    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                      point = _ref[_i];
                      _results.push({
                        x: point.x,
                        y: point.y
                      });
                    }
                    return _results;
                  })(),
                  targetPoints: (function() {
                    var _i, _len, _ref, _results;

                    _ref = tiePoints.targetPoints;
                    _results = [];
                    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                      point = _ref[_i];
                      _results.push({
                        x: point.x,
                        y: point.y
                      });
                    }
                    return _results;
                  })(),
                  polynomialOrder: 1,
                  spatialReference: tiePoints.sourcePoints[0].spatialReference
                }
              }
            ])
          },
          handleAs: "json",
          load: function() {
            var task, _i, _len, _ref;

            _ref = _this.asyncResults.data.filter(function(x) {
              return x.rasterId === _this.currentId && x.task === "Compute Tiepoints";
            });
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              task = _ref[_i];
              delete task.callback;
              task.callbackLabel = "Continue Task";
            }
            if (!gotoLocation) {
              _this.map.setExtent(_this.map.extent);
              return typeof callback === "function" ? callback() : void 0;
            }
            return request({
              url: _this.imageServiceUrl + "/query",
              content: {
                objectIds: _this.currentId,
                returnGeometry: true,
                outFields: "",
                f: "json"
              },
              handleAs: "json",
              load: function(response2) {
                _this.map.setExtent(new Polygon(response2.features[0].geometry).getExtent());
                return typeof callback === "function" ? callback() : void 0;
              },
              error: function(_arg2) {
                var message;

                message = _arg2.message;
                return console.error(message);
              }
            }, {
              usePost: true
            });
          },
          error: function(_arg2) {
            var message;

            message = _arg2.message;
            return console.error(message);
          }
        }, {
          usePost: true
        });
      },
      computeTiePoints: function(callback) {
        var _this = this;

        return request({
          url: this.imageServiceUrl + "/computeTiePoints",
          content: {
            f: "json",
            rasterId: this.currentId,
            geodataTransforms: JSON.stringify([
              {
                geodataTransform: "Identity",
                geodataTransformArguments: {
                  spatialReference: this.rasters.data.filter(function(x) {
                    return x.rasterId === _this.currentId;
                  })[0].spatialReference
                }
              }
            ])
          },
          handleAs: "json",
          timeout: 600000,
          load: function(response) {
            return typeof callback === "function" ? callback(response) : void 0;
          },
          error: function(error) {
            console.error(error.message);
            return typeof callback === "function" ? callback({
              error: error
            }) : void 0;
          }
        }, {
          usePost: true
        });
      },
      toggleRasterLayer: function(state) {
        return this.imageServiceLayer.setOpacity(state ? 1 : 0);
      },
      startEditTiepoints: function() {
        var container, containers, display, _i, _len, _ref;

        if (this.currentId == null) {
          return this.showRasterNotSelectedDialog();
        }
        _ref = {
          none: [this.selectRasterContainer, this.tasksContainer, this.asyncResultsContainer],
          block: [this.editTiepointsContainer]
        };
        for (display in _ref) {
          containers = _ref[display];
          for (_i = 0, _len = containers.length; _i < _len; _i++) {
            container = containers[_i];
            domStyle.set(container.domNode, "display", display);
          }
        }
        return this.refreshMosaicRule();
      },
      collectComputedTiepoints: function() {
        var _this = this;

        this.confirmActionPopupContinueEvent = function() {
          var asyncTask, currentTiepoints;

          _this.confirmActionPopupClose();
          currentTiepoints = (function(func, args, ctor) {
            ctor.prototype = func.prototype;
            var child = new ctor, result = func.apply(child, args);
            return Object(result) === result ? result : child;
          })(Array, _this.tiepoints.data, function(){});
          _this.asyncResults.put(asyncTask = {
            resultId: (Math.max.apply(Math, _this.asyncResults.data.map(function(x) {
              return x.resultId;
            }).concat(0))) + 1,
            task: "Compute Tiepoints",
            rasterId: _this.currentId,
            status: "Pending",
            startTime: (new Date).toLocaleString()
          });
          if (domStyle.get(_this.selectRasterContainer.domNode, "display") === "block") {
            domStyle.set(_this.asyncResultsContainer.domNode, "display", "block");
          }
          _this.asyncResultsGrid.select(asyncTask);
          _this.closeEditTiepoints();
          return _this.computeTiePoints(function(_arg1) {
            var error, tiePoints;

            tiePoints = _arg1.tiePoints, error = _arg1.error;
            extend(asyncTask, {
              status: error != null ? "Failed" : "Completed",
              endTime: (new Date).toLocaleString(),
              callback: function() {
                var container, containers, display, i, newId, sourcePoint, targetPoint, tiepoint, _i, _j, _k, _len, _len1, _ref, _ref1, _results;

                _ref = {
                  none: [_this.selectRasterContainer, _this.tasksContainer, _this.asyncResultsContainer],
                  block: [_this.editTiepointsContainer]
                };
                for (display in _ref) {
                  containers = _ref[display];
                  for (_i = 0, _len = containers.length; _i < _len; _i++) {
                    container = containers[_i];
                    domStyle.set(container.domNode, "display", display);
                  }
                }
                _this.refreshMosaicRule();
                for (_j = 0, _len1 = currentTiepoints.length; _j < _len1; _j++) {
                  tiepoint = currentTiepoints[_j];
                  _this.tiepoints.put(tiepoint);
                  _this.tiepointsLayer.add(tiepoint.sourcePoint);
                  _this.tiepointsLayer.add(tiepoint.targetPoint);
                }
                if (error != null) {
                  return;
                }
                newId = Math.max.apply(Math, _this.tiepoints.data.map(function(x) {
                  return x.id;
                }).concat(0)) + 1;
                _results = [];
                for (i = _k = 0, _ref1 = tiePoints.sourcePoints.length; 0 <= _ref1 ? _k < _ref1 : _k > _ref1; i = 0 <= _ref1 ? ++_k : --_k) {
                  _this.tiepoints.put({
                    id: newId + i,
                    sourcePoint: sourcePoint = new Graphic(new Point(tiePoints.sourcePoints[i]), _this.sourceSymbol),
                    targetPoint: targetPoint = new Graphic(new Point(tiePoints.targetPoints[i]), _this.targetSymbol),
                    original: {
                      sourcePoint: new Point(tiePoints.sourcePoints[i]),
                      targetPoint: new Point(tiePoints.targetPoints[i])
                    }
                  });
                  _this.tiepointsLayer.add(sourcePoint);
                  _results.push(_this.tiepointsLayer.add(targetPoint));
                }
                return _results;
              },
              callbackLabel: "Edit Tiepoints"
            });
            return _this.asyncResults.notify(asyncTask, asyncTask.resultId);
          });
        };
        popup.open({
          popup: this.confirmActionPopup,
          around: this.collectComputedTiepointsButton.domNode,
          orient: ["above", "below"]
        });
        return this.confirmActionPopup.focus();
      },
      closeEditTiepoints: function() {
        var container, containers, display, tiepoint, _i, _j, _len, _len1, _ref, _ref1;

        this.tiepointsLayer.clear();
        _ref = this.tiepoints.data.splice(0);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          tiepoint = _ref[_i];
          this.tiepoints.remove(tiepoint.id);
        }
        _ref1 = {
          block: [this.selectRasterContainer, this.tasksContainer],
          none: [this.editTiepointsContainer]
        };
        for (display in _ref1) {
          containers = _ref1[display];
          for (_j = 0, _len1 = containers.length; _j < _len1; _j++) {
            container = containers[_j];
            domStyle.set(container.domNode, "display", display);
          }
        }
        if (this.asyncResults.data.length > 0) {
          domStyle.set(this.asyncResultsContainer.domNode, "display", "block");
        }
        return this.refreshMosaicRule();
      },
      toggleTiepointsSelection: function() {
        if (this.toggleTiepointsSelectionMenuItem.label === "Clear Selection") {
          return this.tiepointsGrid.clearSelection();
        } else {
          return this.tiepointsGrid.selectAll();
        }
      },
      tiepointsContextMenuOpen: function() {
        return domStyle.set(this.resetTiepointMenuItem.domNode, "display", this.tiepointsGrid.cell(this.tiepointsContextMenu.currentTarget).row.data.original != null ? "table-row" : "none");
      },
      removeTiepoint: function() {
        var graphic, tiepoint, _i, _len, _ref, _results;

        this.tiepoints.remove((tiepoint = this.tiepointsGrid.cell(this.tiepointsContextMenu.currentTarget).row.data).id);
        _ref = [tiepoint.sourcePoint, tiepoint.targetPoint];
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          graphic = _ref[_i];
          _results.push(this.tiepointsLayer.remove(graphic));
        }
        return _results;
      },
      resetTiepoint: function() {
        var key, tiepoint, _i, _len, _ref, _results;

        tiepoint = this.tiepointsGrid.cell(this.tiepointsContextMenu.currentTarget).row.data;
        _ref = ["sourcePoint", "targetPoint"];
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          key = _ref[_i];
          tiepoint[key].setGeometry(tiepoint.original[key]);
          _results.push(tiepoint[key].pointChanged());
        }
        return _results;
      },
      addTiepoint: function(state) {
        var closeMouseTip, contextMenuEvent, currentState, mapDownEvent, mapDragEvent, mapUpEvent, mouseTipDownEvent, mouseTipMoveEvent, sourcePoint, targetPoint,
          _this = this;

        if (state) {
          currentState = "started";
          this.map.setMapCursor("crosshair");
          sourcePoint = null;
          targetPoint = null;
          this.mouseTip.innerHTML = "Click to place Source Point on the map.<br>Right Click to cancel.";
          mouseTipMoveEvent = connect(query("body")[0], "onmousemove", function(e) {
            domStyle.set(_this.mouseTip, "display", "block");
            domStyle.set(_this.mouseTip, "left", e.clientX + 20 + "px");
            return domStyle.set(_this.mouseTip, "top", e.clientY + 20 + "px");
          });
          mouseTipDownEvent = connect(query("body")[0], "onmousedown", function(e) {
            var point, _i, _len, _ref;

            if (_this.toggleRasterLayerButton.hovering) {
              return;
            }
            if (currentState === "placingSourcePoint") {
              return currentState = "placingSourcePoint.1";
            }
            if (currentState === "placingTargetPoint") {
              return currentState = "placingTargetPoint.1";
            }
            if (e.which !== 3) {
              if (typeof closeMouseTip === "function") {
                closeMouseTip();
              }
            }
            _ref = [sourcePoint, targetPoint];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              point = _ref[_i];
              _this.tiepointsLayer.remove(point);
            }
            if (!_this.addTiepointButton.hovering) {
              return _this.addTiepointButton.set("checked", false);
            }
          });
          mapDownEvent = connect(this.map, "onMouseDown", function(e) {
            if (e.which !== 1) {
              return;
            }
            return currentState = (function() {
              switch (currentState) {
                case "started":
                  return "placingSourcePoint";
                case "placedSourcePoint":
                  return "placingTargetPoint";
                default:
                  return currentState;
              }
            })();
          });
          mapUpEvent = connect(this.map, "onMouseUp", function(e) {
            var lastId, tiepoint;

            if (currentState === "placingSourcePoint.1") {
              currentState = "placedSourcePoint";
              sourcePoint = new Graphic(e.mapPoint, _this.sourceSymbol);
              _this.tiepointsLayer.add(sourcePoint);
              return _this.mouseTip.innerHTML = "Click to place Target Point on the map.<br>Right Click to cancel.";
            } else if (currentState === "placingTargetPoint.1") {
              currentState = "placedTargetPoint";
              targetPoint = new Graphic(e.mapPoint, _this.targetSymbol);
              _this.tiepointsLayer.add(targetPoint);
              _this.tiepoints.put(tiepoint = {
                id: lastId = Math.max.apply(Math, _this.tiepoints.data.map(function(x) {
                  return x.id;
                }).concat(0)) + 1,
                sourcePoint: sourcePoint,
                targetPoint: targetPoint
              });
              closeMouseTip();
              return _this.addTiepoint(true);
            }
          });
          mapDragEvent = connect(this.map, "onMouseDrag", function(e) {
            return currentState = (function() {
              switch (currentState) {
                case "placingSourcePoint.1":
                  return "started";
                case "placingTargetPoint.1":
                  return "placingTargetPoint";
                default:
                  return currentState;
              }
            })();
          });
          contextMenuEvent = connect(query("body")[0], "oncontextmenu", function(e) {
            if (typeof closeMouseTip === "function") {
              closeMouseTip();
            }
            return e.preventDefault();
          });
          return closeMouseTip = function() {
            disconnect(mouseTipMoveEvent);
            disconnect(mouseTipDownEvent);
            disconnect(mapDownEvent);
            disconnect(mapUpEvent);
            disconnect(mapDragEvent);
            disconnect(contextMenuEvent);
            domStyle.set(_this.mouseTip, "display", "none");
            _this.mouseTip.innerHTML = "...";
            _this.map.setMapCursor("default");
            return currentState = "placedTiepoint";
          };
        }
      },
      removeSelectedTiepoints: function() {
        var bool, graphic, rowId, tiepoint, _ref, _results;

        _ref = this.tiepointsGrid.selection;
        _results = [];
        for (rowId in _ref) {
          bool = _ref[rowId];
          if (!(bool)) {
            continue;
          }
          this.tiepoints.remove((tiepoint = this.tiepointsGrid.row(rowId).data).id);
          _results.push((function() {
            var _i, _len, _ref1, _results1;

            _ref1 = [tiepoint.sourcePoint, tiepoint.targetPoint];
            _results1 = [];
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
              graphic = _ref1[_i];
              _results1.push(this.tiepointsLayer.remove(graphic));
            }
            return _results1;
          }).call(this));
        }
        return _results;
      },
      resetSelectedTiepoints: function() {
        var bool, key, rowId, tiepoint, _ref, _results;

        _ref = this.tiepointsGrid.selection;
        _results = [];
        for (rowId in _ref) {
          bool = _ref[rowId];
          if (!(bool)) {
            continue;
          }
          tiepoint = this.tiepointsGrid.row(rowId).data;
          if (tiepoint.original == null) {
            continue;
          }
          _results.push((function() {
            var _i, _len, _ref1, _results1;

            _ref1 = ["sourcePoint", "targetPoint"];
            _results1 = [];
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
              key = _ref1[_i];
              tiepoint[key].setGeometry(tiepoint.original[key]);
              _results1.push(tiepoint[key].pointChanged());
            }
            return _results1;
          })());
        }
        return _results;
      },
      applyManualTransform: function() {
        var _this = this;

        domStyle.set(this.loadingGif, "display", "block");
        return this.applyTransform({
          tiePoints: {
            sourcePoints: this.tiepoints.data.map(function(x) {
              return x.sourcePoint.geometry;
            }),
            targetPoints: this.tiepoints.data.map(function(x) {
              return x.targetPoint.geometry;
            })
          }
        }, function() {
          var updateEndEvent;

          return updateEndEvent = connect(_this.imageServiceLayer, "onUpdateEnd", function() {
            disconnect(updateEndEvent);
            _this.closeEditTiepoints();
            return domStyle.set(_this.loadingGif, "display", "none");
          });
        });
      },
      openRoughTransform: function() {
        var container, containers, display, _i, _len, _ref;

        if (this.currentId == null) {
          return this.showRasterNotSelectedDialog();
        }
        _ref = {
          none: [this.selectRasterContainer, this.tasksContainer, this.asyncResultsContainer],
          block: [this.manualTransformContainer]
        };
        for (display in _ref) {
          containers = _ref[display];
          for (_i = 0, _len = containers.length; _i < _len; _i++) {
            container = containers[_i];
            domStyle.set(container.domNode, "display", display);
          }
        }
        return this.refreshMosaicRule();
      },
      closeRoughTransform: function() {
        var button, container, containers, display, _i, _j, _len, _len1, _ref, _ref1;

        _ref = {
          block: [this.selectRasterContainer, this.tasksContainer],
          none: [this.manualTransformContainer]
        };
        for (display in _ref) {
          containers = _ref[display];
          for (_i = 0, _len = containers.length; _i < _len; _i++) {
            container = containers[_i];
            domStyle.set(container.domNode, "display", display);
          }
        }
        if (this.asyncResults.data.length > 0) {
          domStyle.set(this.asyncResultsContainer.domNode, "display", "block");
        }
        _ref1 = [this.rt_moveButton, this.rt_scaleButton, this.rt_rotateButton];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          button = _ref1[_j];
          button.set("checked", false);
        }
        return this.refreshMosaicRule();
      },
      projectIfReq: function(_arg1, callback) {
        var geometries, outSR,
          _this = this;

        geometries = _arg1.geometries, outSR = _arg1.outSR;
        if (geometries.every(function(x) {
          return x.spatialReference.equals(outSR);
        })) {
          return typeof callback === "function" ? callback(geometries) : void 0;
        }
        return this.geometryService.project(extend(new ProjectParameters, {
          geometries: geometries,
          outSR: outSR
        }), function(geometries) {
          return typeof callback === "function" ? callback(geometries) : void 0;
        });
      },
      rt_fit: function() {
        var _this = this;

        if (this.currentId == null) {
          return console.error("No raster selected");
        }
        domStyle.set(this.loadingGif, "display", "block");
        return request({
          url: this.imageServiceUrl + "/query",
          content: {
            objectIds: this.currentId,
            returnGeometry: true,
            outFields: "",
            f: "json"
          },
          handleAs: "json",
          load: function(response1) {
            var src;

            src = new Polygon(response1.features[0].geometry).getExtent();
            return _this.projectIfReq({
              geometries: [_this.map.extent],
              outSR: src.spatialReference
            }, function(_arg1) {
              var mapExtent;

              mapExtent = _arg1[0];
              return request({
                url: _this.imageServiceUrl + "/update",
                content: {
                  f: "json",
                  rasterId: _this.currentId,
                  geodataTransforms: JSON.stringify([
                    {
                      geodataTransform: "Polynomial",
                      geodataTransformArguments: {
                        sourcePoints: [
                          {
                            x: src.xmin,
                            y: src.ymin
                          }, {
                            x: src.xmin,
                            y: src.ymax
                          }, {
                            x: src.xmax,
                            y: src.ymin
                          }
                        ],
                        targetPoints: (function() {
                          var aspectRatio, dest, map;

                          aspectRatio = (src.xmax - src.xmin) / (src.ymax - src.ymin);
                          map = {
                            width: mapExtent.getWidth(),
                            height: mapExtent.getHeight(),
                            center: mapExtent.getCenter()
                          };
                          dest = {
                            width: Math.min(map.width, map.height * aspectRatio),
                            height: Math.min(map.height, map.width / aspectRatio)
                          };
                          dest.xmin = map.center.x - dest.width / 2;
                          dest.xmax = map.center.x + dest.width / 2;
                          dest.ymin = map.center.y - dest.height / 2;
                          dest.ymax = map.center.y + dest.height / 2;
                          return [
                            {
                              x: dest.xmin,
                              y: dest.ymin
                            }, {
                              x: dest.xmin,
                              y: dest.ymax
                            }, {
                              x: dest.xmax,
                              y: dest.ymin
                            }
                          ];
                        })(),
                        polynomialOrder: 1,
                        spatialReference: src.spatialReference
                      }
                    }
                  ])
                },
                handleAs: "json",
                load: function() {
                  return request({
                    url: _this.imageServiceUrl + "/query",
                    content: {
                      objectIds: _this.currentId,
                      returnGeometry: true,
                      outFields: "",
                      f: "json"
                    },
                    handleAs: "json",
                    load: function(response3) {
                      var updateEndEvent;

                      _this.map.setExtent(new Polygon(response3.features[0].geometry).getExtent());
                      return updateEndEvent = connect(_this.imageServiceLayer, "onUpdateEnd", function() {
                        disconnect(updateEndEvent);
                        return domStyle.set(_this.loadingGif, "display", "none");
                      });
                    },
                    error: function(_arg2) {
                      var message;

                      message = _arg2.message;
                      return console.error(message);
                    }
                  }, {
                    usePost: true
                  });
                },
                error: function(_arg2) {
                  var message;

                  message = _arg2.message;
                  return console.error(message);
                }
              }, {
                usePost: true
              });
            });
          },
          error: function(_arg1) {
            var message;

            message = _arg1.message;
            return console.error(message);
          }
        }, {
          usePost: true
        });
      },
      rt_move: function(state) {
        var button, theGrid, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _results,
          _this = this;

        if (state) {
          domStyle.set(this.rtMoveContainer.domNode, "display", "block");
          _ref = [this.rt_scaleButton, this.rt_rotateButton];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            button = _ref[_i];
            button.set("checked", false);
          }
          _ref1 = [this.rtMoveFromGrid, this.rtMoveToGrid];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            theGrid = _ref1[_j];
            theGrid.set("onPointChanged", function() {
              var thePoint;

              thePoint = new Graphic(new Point({
                x: Number(theGrid.get("x")),
                y: Number(theGrid.get("y")),
                spatialReference: _this.map.spatialReference
              }), theGrid === _this.rtMoveFromGrid ? _this.sourceSymbol : _this.targetSymbol);
              _this.miscGraphicsLayer.add(thePoint);
              theGrid.set("onPointChanged", function(_arg1) {
                var point, x, y;

                x = _arg1.x, y = _arg1.y;
                point = new Point(thePoint.geometry);
                point.x = x;
                point.y = y;
                return thePoint.setGeometry(point);
              });
              thePoint.pointChanged = function() {
                return theGrid.setPoint({
                  x: thePoint.geometry.x,
                  y: thePoint.geometry.y
                });
              };
              return theGrid.graphic = thePoint;
            });
          }
          return this.rtMoveFromPick(true);
        } else {
          domStyle.set(this.rtMoveContainer.domNode, "display", "none");
          _ref2 = [this.rtMoveFromGrid, this.rtMoveToGrid];
          _results = [];
          for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
            theGrid = _ref2[_k];
            theGrid.setPoint({
              x: "",
              y: ""
            });
            theGrid.set("onPointChanged", null);
            if (theGrid.graphic != null) {
              this.miscGraphicsLayer.remove(theGrid.graphic);
            }
            _results.push(delete theGrid.graphic);
          }
          return _results;
        }
      },
      rt_moveClose: function() {
        return this.rt_moveButton.set("checked", false);
      },
      rtMovePick: function(_arg1) {
        var closeMouseTip, contextMenuEvent, currentState, mapDownEvent, mapDragEvent, mapUpEvent, mouseTipDownEvent, mouseTipMoveEvent, state, theButton, theGrid, thePoint, which,
          _this = this;

        which = _arg1.which, state = _arg1.state;
        if (state) {
          currentState = "started";
          this.map.setMapCursor("crosshair");
          thePoint = null;
          theButton = which === "from" ? this.rtMoveFromPickButton : this.rtMoveToPickButton;
          theGrid = which === "from" ? this.rtMoveFromGrid : this.rtMoveToGrid;
          this.mouseTip.innerHTML = "Click to place " + (which === "from" ? "Source" : "Target") + " Point on the map.<br>Right Click to cancel.";
          mouseTipMoveEvent = connect(query("body")[0], "onmousemove", function(e) {
            domStyle.set(_this.mouseTip, "display", "block");
            domStyle.set(_this.mouseTip, "left", e.clientX + 20 + "px");
            return domStyle.set(_this.mouseTip, "top", e.clientY + 20 + "px");
          });
          mouseTipDownEvent = connect(query("body")[0], "onmousedown", function(e) {
            if (_this.toggleRasterLayerButton.hovering) {
              return;
            }
            if (currentState === "placingPoint") {
              return currentState = "placingPoint.1";
            }
            if (e.which !== 3) {
              if (typeof closeMouseTip === "function") {
                closeMouseTip();
              }
            }
            _this.miscGraphicsLayer.remove(thePoint);
            if (!theButton.hovering) {
              return theButton.set("checked", false);
            }
          });
          mapDownEvent = connect(this.map, "onMouseDown", function(e) {
            if (e.which !== 1) {
              return;
            }
            if (currentState === "started") {
              return currentState = "placingPoint";
            }
          });
          mapUpEvent = connect(this.map, "onMouseUp", function(e) {
            if (currentState === "placingPoint.1") {
              currentState = "placedPoint";
              thePoint = new Graphic(e.mapPoint, which === "from" ? _this.sourceSymbol : _this.targetSymbol);
              if (theGrid.graphic != null) {
                _this.miscGraphicsLayer.remove(theGrid.graphic);
              }
              _this.miscGraphicsLayer.add(thePoint);
              theGrid.setPoint({
                x: e.mapPoint.x,
                y: e.mapPoint.y
              });
              theGrid.set("onPointChanged", function(_arg2) {
                var point, x, y;

                x = _arg2.x, y = _arg2.y;
                point = new Point(thePoint.geometry);
                point.x = x;
                point.y = y;
                return thePoint.setGeometry(point);
              });
              thePoint.pointChanged = function() {
                return theGrid.setPoint({
                  x: thePoint.geometry.x,
                  y: thePoint.geometry.y
                });
              };
              theGrid.graphic = thePoint;
              closeMouseTip();
              theButton.set("checked", false);
              if (theButton === _this.rtMoveFromPickButton) {
                return _this.rtMoveToPickButton.set("checked", true);
              }
            }
          });
          mapDragEvent = connect(this.map, "onMouseDrag", function(e) {
            return currentState = (function() {
              switch (currentState) {
                case "placingPoint.1":
                  return "started";
                default:
                  return currentState;
              }
            })();
          });
          contextMenuEvent = connect(query("body")[0], "oncontextmenu", function(e) {
            if (typeof closeMouseTip === "function") {
              closeMouseTip();
            }
            return e.preventDefault();
          });
          return closeMouseTip = function() {
            disconnect(mouseTipMoveEvent);
            disconnect(mouseTipDownEvent);
            disconnect(mapDownEvent);
            disconnect(mapUpEvent);
            disconnect(mapDragEvent);
            disconnect(contextMenuEvent);
            domStyle.set(_this.mouseTip, "display", "none");
            _this.mouseTip.innerHTML = "...";
            _this.map.setMapCursor("default");
            return currentState = "placedMovePoint";
          };
        }
      },
      rtMoveFromPick: function(state) {
        return this.rtMovePick({
          which: "from",
          state: state
        });
      },
      rtMoveToPick: function(state) {
        return this.rtMovePick({
          which: "to",
          state: state
        });
      },
      rt_moveTransform: function() {
        var _ref, _ref1,
          _this = this;

        domStyle.set(this.loadingGif, "display", "block");
        return this.projectIfReq({
          geometries: [new Point((_ref = this.rtMoveFromGrid.graphic) != null ? _ref.geometry : void 0), new Point((_ref1 = this.rtMoveToGrid.graphic) != null ? _ref1.geometry : void 0)],
          outSR: this.rasters.data.filter(function(x) {
            return x.rasterId === _this.currentId;
          })[0].spatialReference
        }, function(_arg1) {
          var fromPoint, offsets, point, toPoint;

          fromPoint = _arg1[0], toPoint = _arg1[1];
          return _this.applyTransform({
            tiePoints: {
              sourcePoints: (function() {
                var _i, _len, _ref2, _results;

                _ref2 = [[0, 0], [10, 0], [0, 10]];
                _results = [];
                for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
                  offsets = _ref2[_i];
                  point = new Point(fromPoint);
                  point.x += offsets[0];
                  point.y += offsets[1];
                  _results.push(point);
                }
                return _results;
              })(),
              targetPoints: (function() {
                var _i, _len, _ref2, _results;

                _ref2 = [[0, 0], [10, 0], [0, 10]];
                _results = [];
                for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
                  offsets = _ref2[_i];
                  point = new Point(toPoint);
                  point.x += offsets[0];
                  point.y += offsets[1];
                  _results.push(point);
                }
                return _results;
              })()
            },
            gotoLocation: false
          }, function() {
            var updateEndEvent;

            return updateEndEvent = connect(_this.imageServiceLayer, "onUpdateEnd", function() {
              disconnect(updateEndEvent);
              _this.rt_moveClose();
              return domStyle.set(_this.loadingGif, "display", "none");
            });
          });
        });
      },
      rt_scale: function(state) {
        var button, _i, _len, _ref, _results;

        if (state) {
          domStyle.set(this.rtScaleContainer.domNode, "display", "block");
          _ref = [this.rt_moveButton, this.rt_rotateButton];
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            button = _ref[_i];
            _results.push(button.set("checked", false));
          }
          return _results;
        } else {
          domStyle.set(this.rtScaleContainer.domNode, "display", "none");
          return this.rtScaleFactorInput.value = "";
        }
      },
      rt_scaleClose: function() {
        return this.rt_scaleButton.set("checked", false);
      },
      rt_scaleTransform: function() {
        var _this = this;

        domStyle.set(this.loadingGif, "display", "block");
        return request({
          url: this.imageServiceUrl + "/query",
          content: {
            objectIds: this.currentId,
            returnGeometry: true,
            outFields: "",
            f: "json"
          },
          handleAs: "json",
          load: function(response) {
            var centerPoint, offsets, point, scaleFactor;

            scaleFactor = !isNaN(_this.rtScaleFactorInput.value) ? Number(_this.rtScaleFactorInput.value) : 1;
            centerPoint = new Polygon(response.features[0].geometry).getExtent().getCenter();
            return _this.applyTransform({
              tiePoints: {
                sourcePoints: (function() {
                  var _i, _len, _ref, _results;

                  _ref = [[0, 0], [10, 0], [0, 10]];
                  _results = [];
                  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                    offsets = _ref[_i];
                    point = new Point(centerPoint);
                    point.x += offsets[0];
                    point.y += offsets[1];
                    _results.push(point);
                  }
                  return _results;
                })(),
                targetPoints: (function() {
                  var _i, _len, _ref, _results;

                  _ref = [[0, 0], [10 * scaleFactor, 0], [0, 10 * scaleFactor]];
                  _results = [];
                  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                    offsets = _ref[_i];
                    point = new Point(centerPoint);
                    point.x += offsets[0];
                    point.y += offsets[1];
                    _results.push(point);
                  }
                  return _results;
                })()
              },
              gotoLocation: false
            }, function() {
              var updateEndEvent;

              return updateEndEvent = connect(_this.imageServiceLayer, "onUpdateEnd", function() {
                disconnect(updateEndEvent);
                _this.rt_scaleClose();
                return domStyle.set(_this.loadingGif, "display", "none");
              });
            });
          },
          error: function(_arg1) {
            var message;

            message = _arg1.message;
            return console.error(message);
          }
        }, {
          usePost: true
        });
      },
      rt_rotate: function(state) {
        var button, _i, _len, _ref, _results;

        if (state) {
          domStyle.set(this.rtRotateContainer.domNode, "display", "block");
          _ref = [this.rt_moveButton, this.rt_scaleButton];
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            button = _ref[_i];
            _results.push(button.set("checked", false));
          }
          return _results;
        } else {
          domStyle.set(this.rtRotateContainer.domNode, "display", "none");
          return this.rtRotateDegreesInput.value = "";
        }
      },
      rt_rotateClose: function() {
        return this.rt_rotateButton.set("checked", false);
      },
      rt_rotateTransform: function() {
        var _this = this;

        domStyle.set(this.loadingGif, "display", "block");
        return request({
          url: this.imageServiceUrl + "/query",
          content: {
            objectIds: this.currentId,
            returnGeometry: true,
            outFields: "",
            f: "json"
          },
          handleAs: "json",
          load: function(response) {
            var PI, centerPoint, cos, offsets, point, sin, theta;

            sin = Math.sin, cos = Math.cos, PI = Math.PI;
            theta = !isNaN(_this.rtRotateDegreesInput.value) ? PI / 180 * Number(_this.rtRotateDegreesInput.value) : 0;
            centerPoint = new Polygon(response.features[0].geometry).getExtent().getCenter();
            return _this.applyTransform({
              tiePoints: {
                sourcePoints: (function() {
                  var _i, _len, _ref, _results;

                  _ref = [[0, 0], [10, 0], [0, 10]];
                  _results = [];
                  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                    offsets = _ref[_i];
                    point = new Point(centerPoint);
                    point.x += offsets[0];
                    point.y += offsets[1];
                    _results.push(point);
                  }
                  return _results;
                })(),
                targetPoints: (function() {
                  var _i, _len, _ref, _results;

                  _ref = [[0, 0], [10 * cos(theta), 10 * -sin(theta)], [10 * sin(theta), 10 * cos(theta)]];
                  _results = [];
                  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                    offsets = _ref[_i];
                    point = new Point(centerPoint);
                    point.x += offsets[0];
                    point.y += offsets[1];
                    _results.push(point);
                  }
                  return _results;
                })()
              },
              gotoLocation: false
            }, function() {
              var updateEndEvent;

              return updateEndEvent = connect(_this.imageServiceLayer, "onUpdateEnd", function() {
                disconnect(updateEndEvent);
                _this.rt_rotateClose();
                return domStyle.set(_this.loadingGif, "display", "none");
              });
            });
          },
          error: function(_arg1) {
            var message;

            message = _arg1.message;
            return console.error(message);
          }
        }, {
          usePost: true
        });
      },
      showRasterNotSelectedDialog: function() {
        return this.rasterNotSelectedDialog.show();
      },
      hideRasterNotSelectedDialog: function() {
        return this.rasterNotSelectedDialog.hide();
      },
      selectBasemap: function(selectedMenuItem) {
        var layerId, menuItem, menuItems, _i, _j, _len, _len1, _ref, _results;

        menuItems = [this.selectBasemap_SatelliteButton, this.selectBasemap_HybridButton, this.selectBasemap_TopographicButton, this.selectBasemap_StreetsButton, this.selectBasemap_NaturalVueButton];
        for (_i = 0, _len = menuItems.length; _i < _len; _i++) {
          menuItem = menuItems[_i];
          if (menuItem !== selectedMenuItem) {
            query(menuItem.domNode).removeClass("bold");
          }
        }
        query(selectedMenuItem.domNode).addClass("bold");
        if (this.naturalVueServiceLayer != null) {
          this.map.removeLayer(this.naturalVueServiceLayer);
          delete this.naturalVueServiceLayer;
          _ref = this.map.basemapLayerIds;
          _results = [];
          for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
            layerId = _ref[_j];
            _results.push(this.map.getLayer(layerId).setVisibility(true));
          }
          return _results;
        }
      },
      selectBasemap_Satellite: function() {
        this.selectBasemap(this.selectBasemap_SatelliteButton);
        return this.map.setBasemap("satellite");
      },
      selectBasemap_Hybrid: function() {
        this.selectBasemap(this.selectBasemap_HybridButton);
        return this.map.setBasemap("hybrid");
      },
      selectBasemap_Topographic: function() {
        this.selectBasemap(this.selectBasemap_TopographicButton);
        return this.map.setBasemap("topo");
      },
      selectBasemap_Streets: function() {
        this.selectBasemap(this.selectBasemap_StreetsButton);
        return this.map.setBasemap("streets");
      },
      selectBasemap_NaturalVue: function() {
        var layerId, _i, _len, _ref, _results;

        this.selectBasemap(this.selectBasemap_NaturalVueButton);
        this.map.addLayer((this.naturalVueServiceLayer = new ArcGISTiledMapServiceLayer(this.naturalVueServiceUrl)), 1);
        _ref = this.map.basemapLayerIds;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          layerId = _ref[_i];
          _results.push(this.map.getLayer(layerId).setVisibility(false));
        }
        return _results;
      },
      atdpClose: function() {
        popup.close(this.asyncTaskDetailsPopup);
        return this.asyncResultsGrid.clearSelection();
      },
      atdpContinue: function() {
        return typeof this.atdpContinueEvent === "function" ? this.atdpContinueEvent() : void 0;
      },
      atdpRemove: function() {
        var bool, rowId, _ref;

        _ref = this.asyncResultsGrid.selection;
        for (rowId in _ref) {
          bool = _ref[rowId];
          if (bool) {
            this.asyncResults.remove(rowId);
          }
        }
        this.atdpClose();
        if (this.asyncResults.data.length === 0) {
          return domStyle.set(this.asyncResultsContainer.domNode, "display", "none");
        }
      },
      confirmActionPopupClose: function() {
        return popup.close(this.confirmActionPopup);
      },
      confirmActionPopupContinue: function() {
        return typeof this.confirmActionPopupContinueEvent === "function" ? this.confirmActionPopupContinueEvent() : void 0;
      },
      setImageFormat: function(selectedMenuItem) {
        var menuItem, menuItems, _i, _len;

        menuItems = [this.setImageFormat_JPGPNGButton, this.setImageFormat_JPGButton];
        for (_i = 0, _len = menuItems.length; _i < _len; _i++) {
          menuItem = menuItems[_i];
          if (menuItem !== selectedMenuItem) {
            query(menuItem.domNode).removeClass("bold");
          }
        }
        return query(selectedMenuItem.domNode).addClass("bold");
      },
      setImageFormat_JPGPNG: function() {
        this.setImageFormat(this.setImageFormat_JPGPNGButton);
        return this.imageServiceLayer.setImageFormat("jpgpng");
      },
      setImageFormat_JPG: function() {
        this.setImageFormat(this.setImageFormat_JPGButton);
        return this.imageServiceLayer.setImageFormat("jpg");
      },
      rastersDisplay_enableAll: function() {
        var bool, raster, rowId, selectedRowId, _i, _len, _ref, _ref1;

        _ref = this.rastersGrid.selection;
        for (rowId in _ref) {
          bool = _ref[rowId];
          if (bool) {
            selectedRowId = rowId;
          }
        }
        _ref1 = this.rasters.data;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          raster = _ref1[_i];
          raster.display = true;
          this.rasters.notify(raster, raster.rasterId);
        }
        if (selectedRowId != null) {
          this.rastersGrid.select(selectedRowId);
        }
        return this.refreshMosaicRule();
      },
      rastersDisplay_disableAll: function() {
        var bool, raster, rowId, selectedRowId, _i, _len, _ref, _ref1;

        _ref = this.rastersGrid.selection;
        for (rowId in _ref) {
          bool = _ref[rowId];
          if (bool) {
            selectedRowId = rowId;
          }
        }
        _ref1 = this.rasters.data;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          raster = _ref1[_i];
          raster.display = false;
          this.rasters.notify(raster, raster.rasterId);
        }
        if (selectedRowId != null) {
          this.rastersGrid.select(selectedRowId);
        }
        return this.refreshMosaicRule();
      }
    });
  });
})();

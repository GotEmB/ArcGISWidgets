// Generated by CoffeeScript 1.6.2
var extend;

extend = function(obj, mixin) {
  var method, name;

  for (name in mixin) {
    method = mixin[name];
    obj[name] = method;
  }
  return obj;
};

define(["dojo/_base/declare", "dijit/_WidgetBase", "dijit/_TemplatedMixin", "dijit/_WidgetsInTemplateMixin", "dojo/text!./GeorefWidget/templates/GeorefWidget.html", "dojo/_base/connect", "esri/layers/ArcGISImageServiceLayer", "esri/request", "esri/layers/MosaicRule", "esri/geometry/Polygon", "esri/tasks/GeometryService", "dojo/dom-style", "dojox/form/FileInput", "dijit/form/Button", "dijit/layout/AccordionContainer", "dijit/layout/ContentPane", "gotemb/GeorefWidget/Grid", "dijit/Dialog", "dijit/Toolbar", "dijit/ToolbarSeparator", "dijit/form/ToggleButton"], function(declare, _WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin, template, _arg, ArcGISImageServiceLayer, request, MosaicRule, Polygon, GeometryService, domStyle) {
  var connect;

  connect = _arg.connect;
  return declare([_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin], {
    templateString: template,
    baseClass: "ClassifyWidget",
    map: null,
    imageFile: null,
    uploadForm: null,
    imageServiceUrl: "http://eg1109:6080/arcgis/rest/services/amberg_wgs/ImageServer",
    imageServiceLayer: null,
    referenceLayerUrl: "http://eg1109:6080/arcgis/rest/services/amberg_wgs_reference/ImageServer",
    referenceLayer: null,
    geometryServiceUrl: "http://lamborghini:6080/arcgis/rest/services/Utilities/Geometry/GeometryServer",
    geometryService: null,
    rastertype: null,
    currentId: null,
    rastersGrid: null,
    addRasterDialog: null,
    selectRasterContainer: null,
    transformContainer: null,
    editTiepointsContainer: null,
    postCreate: function() {
      var _this = this;

      this.imageServiceLayer = new ArcGISImageServiceLayer(this.imageServiceUrl);
      this.geometryService = new GeometryService(this.geometryServiceUrl);
      return connect(this.imageServiceLayer, "onLoad", function() {
        _this.map.addLayer(_this.referenceLayer = new ArcGISImageServiceLayer(_this.referenceLayerUrl));
        _this.imageServiceLayer.setOpacity(0);
        _this.map.addLayer(_this.imageServiceLayer);
        _this.rastersGrid.set("columns", {
          id: "Raster Id",
          name: "Name"
        });
        _this.rastersGrid.set("selectionMode", "single");
        return _this.loadRastersList(function() {
          return _this.rastersGrid.on("dgrid-select", function(_arg1) {
            var rows;

            rows = _arg1.rows;
            _this.currentId = rows[0].data.id;
            _this.imageServiceLayer.setMosaicRule(extend(new MosaicRule, {
              method: MosaicRule.METHOD_LOCKRASTER,
              lockRasterIds: [_this.currentId]
            }), true);
            return request({
              url: _this.imageServiceUrl + "/query",
              content: {
                objectIds: [_this.currentId],
                returnGeometry: true,
                outFields: "",
                f: "json"
              },
              handleAs: "json",
              load: function(response3) {
                _this.map.setExtent(new Polygon(response3.features[0].geometry).getExtent().expand(2));
                return _this.imageServiceLayer.setOpacity(1);
              },
              error: console.error
            }, {
              usePost: true
            });
          });
        });
      });
    },
    loadRastersList: function(callback) {
      var _this = this;

      return request({
        url: this.imageServiceUrl + "/query",
        content: {
          f: "json",
          outFields: "OBJECTID, Name",
          returnGeometry: false
        },
        handlesAs: "json",
        load: function(response) {
          var feature, features;

          _this.rastersGrid.refresh();
          _this.rastersGrid.renderArray(features = (function() {
            var _i, _len, _ref, _results;

            _ref = response.features;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              feature = _ref[_i];
              _results.push({
                id: feature.attributes.OBJECTID,
                name: feature.attributes.Name
              });
            }
            return _results;
          })());
          return typeof callback === "function" ? callback(features) : void 0;
        },
        error: console.error
      }, {
        usePost: true
      });
    },
    showAddRasterDialog: function() {
      return this.addRasterDialog.show();
    },
    addRasterDialog_upload: function() {
      var _this = this;

      if (this.imageFile.value.length === 0) {
        return console.error("An image must be selected!");
      }
      this.rastertype = this.imageFile.value.indexOf("las") === -1 ? "Raster Dataset" : "HillshadedLAS";
      console.info("Step 1/3: Uploading...");
      return request({
        url: this.imageServiceUrl + "/uploads/upload",
        form: this.uploadForm,
        content: {
          f: "json"
        },
        handleAs: "json",
        timeout: 600000,
        load: function(response1) {
          if (!response1.success) {
            return console.error("Unsuccessful upload:\n" + response1);
          }
          console.info("Step 2/3: Uploaded, processing the image on server side...");
          return request({
            url: _this.imageServiceUrl + "/add",
            content: {
              itemIds: response1.item.itemID,
              rasterType: _this.rastertype,
              minimumCellSizeFactor: 0.1,
              maximumCellSizeFactor: 10,
              f: "json"
            },
            handleAs: "json",
            load: function(response2) {
              var id;

              if (id = response2.addResults[0].rasterId) {
                return _this.loadRastersList(function(features) {
                  _this.addRasterDialog.hide();
                  _this.rastersGrid.clearSelection();
                  if (features.length > 0) {
                    return _this.rastersGrid.select(features.length - 1);
                  }
                });
              }
            },
            error: console.error
          }, {
            usePost: true
          });
        },
        error: console.error
      }, {
        usePost: true
      });
    },
    roughTransform: function() {
      var _this = this;

      if (this.currentId == null) {
        return console.error("An image must be uploaded in step 1.");
      }
      return request({
        url: this.imageServiceUrl + ("/" + this.currentId + "/info"),
        content: {
          f: "json"
        },
        handleAs: "json",
        load: function(response1) {
          var src;

          src = response1.extent;
          return request({
            url: _this.imageServiceUrl + "/update",
            content: {
              f: "json",
              rasterId: _this.currentId,
              geodataTransforms: JSON.stringify([
                {
                  geodataTransform: "Polynomial",
                  geodataTransformArguments: {
                    sourcePoints: [
                      {
                        x: src.xmin,
                        y: src.ymin
                      }, {
                        x: src.xmin,
                        y: src.ymax
                      }, {
                        x: src.xmax,
                        y: src.ymin
                      }
                    ],
                    targetPoints: (function() {
                      var aspectRatio, dest, map;

                      aspectRatio = (src.xmax - src.xmin) / (src.ymax - src.ymin);
                      map = {
                        width: _this.map.extent.getWidth(),
                        height: _this.map.extent.getHeight(),
                        center: _this.map.extent.getCenter().toJson()
                      };
                      dest = {
                        width: Math.min(map.width, map.height * aspectRatio),
                        height: Math.min(map.height, map.width / aspectRatio)
                      };
                      dest.xmin = map.center.x - dest.width / 2;
                      dest.xmax = map.center.x + dest.width / 2;
                      dest.ymin = map.center.y - dest.height / 2;
                      dest.ymax = map.center.y + dest.height / 2;
                      return [
                        {
                          x: dest.xmin,
                          y: dest.ymin
                        }, {
                          x: dest.xmin,
                          y: dest.ymax
                        }, {
                          x: dest.xmax,
                          y: dest.ymin
                        }
                      ];
                    })(),
                    polynomialOrder: 1,
                    spatialReference: src.spatialReference
                  }
                }
              ])
            },
            handleAs: "json",
            load: function() {
              return request({
                url: _this.imageServiceUrl + "/query",
                content: {
                  objectIds: _this.currentId,
                  returnGeometry: true,
                  outFields: "",
                  f: "json"
                },
                handleAs: "json",
                load: function(response3) {
                  return _this.map.setExtent(new Polygon(response3.features[0].geometry).getExtent().expand(2));
                },
                error: console.error
              }, {
                usePost: true
              });
            },
            error: console.error
          }, {
            usePost: true
          });
        },
        error: console.error
      }, {
        usePost: true
      });
    },
    computeAndTransform: function() {
      var _this = this;

      if (this.currentId == null) {
        return console.error("Please select a raster.");
      }
      return request({
        url: this.imageServiceUrl + ("/" + this.currentId + "/info"),
        content: {
          f: "json"
        },
        handleAs: "json",
        load: function(response1) {
          var src;

          src = response1.extent;
          return request({
            url: _this.imageServiceUrl + "/computeTiePoints",
            content: {
              f: "json",
              rasterId: _this.currentId,
              geodataTransforms: JSON.stringify([
                {
                  geodataTransform: "Identity",
                  geodataTransformArguments: {
                    spatialReference: src.spatialReference
                  }
                }
              ])
            },
            handleAs: "json",
            load: function(response2) {
              var point;

              return request({
                url: _this.imageServiceUrl + "/update",
                content: {
                  f: "json",
                  rasterId: _this.currentId,
                  geodataTransforms: JSON.stringify([
                    {
                      geodataTransform: "Polynomial",
                      geodataTransformArguments: {
                        sourcePoints: (function() {
                          var _i, _len, _ref, _results;

                          _ref = response2.tiePoints.sourcePoints;
                          _results = [];
                          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                            point = _ref[_i];
                            _results.push({
                              x: point.x,
                              y: point.y
                            });
                          }
                          return _results;
                        })(),
                        targetPoints: (function() {
                          var _i, _len, _ref, _results;

                          _ref = response2.tiePoints.targetPoints;
                          _results = [];
                          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                            point = _ref[_i];
                            _results.push({
                              x: point.x,
                              y: point.y
                            });
                          }
                          return _results;
                        })(),
                        polynomialOrder: 1,
                        spatialReference: response2.tiePoints.sourcePoints[0].spatialReference
                      }
                    }
                  ])
                },
                handleAs: "json",
                load: function() {
                  return request({
                    url: _this.imageServiceUrl + "/query",
                    content: {
                      objectIds: _this.currentId,
                      returnGeometry: true,
                      outFields: "",
                      f: "json"
                    },
                    handleAs: "json",
                    load: function(response3) {
                      return _this.map.setExtent(new Polygon(response3.features[0].geometry).getExtent().expand(2));
                    },
                    error: console.error
                  });
                },
                error: console.error
              }, {
                usePost: true
              });
            },
            error: console.error
          }, {
            usePost: true
          });
        },
        error: console.error
      }, {
        usePost: true
      });
    },
    toggleReferenceLayer: function(state) {
      return this.referenceLayer.setOpacity(state ? 1 : 0);
    },
    startEditTiepoints: function() {
      domStyle.set(this.selectRasterContainer.domNode, "display", "none");
      domStyle.set(this.transformContainer.domNode, "display", "none");
      return domStyle.set(this.editTiepointsContainer.domNode, "display", "block");
    },
    closeEditTiepoints: function() {
      domStyle.set(this.selectRasterContainer.domNode, "display", "block");
      domStyle.set(this.transformContainer.domNode, "display", "block");
      return domStyle.set(this.editTiepointsContainer.domNode, "display", "none");
    }
  });
});

// Generated by CoffeeScript 1.6.2
var extend;

extend = function(obj, mixin) {
  var method, name;

  for (name in mixin) {
    method = mixin[name];
    obj[name] = method;
  }
  return obj;
};

define(["dojo/_base/declare", "dijit/_WidgetBase", "dijit/_TemplatedMixin", "dijit/_WidgetsInTemplateMixin", "dojo/text!./GeorefWidget/templates/GeorefWidget.html", "dojo/_base/connect", "esri/layers/ArcGISImageServiceLayer", "esri/request", "esri/layers/MosaicRule", "esri/geometry/Polygon", "esri/tasks/GeometryService", "dojox/form/FileInput", "dijit/form/Button"], function(declare, _WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin, template, _arg, ArcGISImageServiceLayer, request, MosaicRule, Polygon, GeometryService) {
  var connect;

  connect = _arg.connect;
  return declare([_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin], {
    templateString: template,
    baseClass: "ClassifyWidget",
    map: null,
    imageFile: null,
    uploadForm: null,
    imageServiceUrl: "http://lamborghini.uae.esri.com:6080/arcgis/rest/services/amberg_gcs_1/ImageServer",
    imageServiceLayer: null,
    referenceLayerUrl: "http://lamborghini.uae.esri.com:6080/arcgis/rest/services/amberg_gcs_reference/ImageServer",
    referenceLayer: null,
    geometryServiceUrl: "http://lamborghini:6080/arcgis/rest/services/Utilities/Geometry/GeometryServer",
    geometryService: null,
    rastertype: null,
    imageIDs: [],
    currentId: null,
    postCreate: function() {
      var _this = this;

      this.imageServiceLayer = new ArcGISImageServiceLayer(this.imageServiceUrl);
      this.geometryService = new GeometryService(this.geometryServiceUrl);
      return connect(this.imageServiceLayer, "onLoad", function() {
        _this.map.addLayer(_this.referenceLayer = new ArcGISImageServiceLayer(_this.referenceLayerUrl));
        _this.imageServiceLayer.setOpacity(0);
        return _this.map.addLayer(_this.imageServiceLayer);
      });
    },
    upload: function() {
      var _this = this;

      if (this.imageFile.value.length === 0) {
        return console.error("An image must be selected!");
      }
      this.rastertype = this.imageFile.value.indexOf("las") === -1 ? "Raster Dataset" : "HillshadedLAS";
      console.info("Step 1/3: Uploading...");
      return request({
        url: this.imageServiceUrl + "/uploads/upload",
        form: this.uploadForm,
        content: {
          f: "json"
        },
        handleAs: "json",
        timeout: 600000,
        load: function(response1) {
          if (!response1.success) {
            return console.error("Unsuccessful upload:\n" + response1);
          }
          console.info("Step 2/3: Uploaded, processing the image on server side...");
          return request({
            url: _this.imageServiceUrl + "/add",
            content: {
              itemIds: response1.item.itemID,
              rasterType: _this.rastertype,
              minimumCellSizeFactor: 0.1,
              maximumCellSizeFactor: 10,
              f: "json"
            },
            handleAs: "json",
            load: function(response2) {
              var id;

              if (id = response2.addResults[0].rasterId) {
                console.info("Step 3/3: Navigate to the image.");
                _this.imageIDs.push(id.toString());
                _this.currentId = id;
                if (_this.imageIDs.length > 0) {
                  _this.imageServiceLayer.setMosaicRule(extend(new MosaicRule, {
                    method: MosaicRule.METHOD_LOCKRASTER,
                    lockRasterIds: _this.imageIDs
                  }), true);
                }
                return request({
                  url: _this.imageServiceUrl + "/query",
                  content: {
                    objectIds: id,
                    returnGeometry: true,
                    outFields: "",
                    f: "json"
                  },
                  handleAs: "json",
                  load: function(response3) {
                    _this.map.setExtent(new Polygon(response3.features[0].geometry).getExtent().expand(2));
                    _this.imageServiceLayer.setOpacity(1);
                    return console.info("Succeeded!");
                  },
                  error: console.error
                });
              }
            },
            error: console.error
          }, {
            usePost: true
          });
        },
        error: console.error
      });
    },
    roughTransform: function() {
      var _this = this;

      if (this.currentId == null) {
        return console.error("An image must be uploaded in step 1.");
      }
      return request({
        url: this.imageServiceUrl + ("/" + this.currentId + "/info"),
        content: {
          f: "json"
        },
        handleAs: "json",
        load: function(response1) {
          var src;

          src = response1.extent;
          return request({
            url: _this.imageServiceUrl + "/update",
            content: {
              f: "json",
              rasterId: _this.currentId,
              geodataTransforms: JSON.stringify([
                {
                  geodataTransform: "Polynomial",
                  geodataTransformArguments: {
                    sourcePoints: [
                      {
                        x: src.xmin,
                        y: src.ymin
                      }, {
                        x: src.xmin,
                        y: src.ymax
                      }, {
                        x: src.xmax,
                        y: src.ymin
                      }
                    ],
                    targetPoints: (function() {
                      var aspectRatio, dest, map;

                      aspectRatio = (src.xmax - src.xmin) / (src.ymax - src.ymin);
                      map = {
                        width: _this.map.extent.getWidth(),
                        height: _this.map.extent.getHeight(),
                        center: _this.map.extent.getCenter().toJson()
                      };
                      dest = {
                        width: Math.min(map.width, map.height * aspectRatio),
                        height: Math.min(map.height, map.width / aspectRatio)
                      };
                      dest.xmin = map.center.x - dest.width / 2;
                      dest.xmax = map.center.x + dest.width / 2;
                      dest.ymin = map.center.y - dest.height / 2;
                      dest.ymax = map.center.y + dest.height / 2;
                      return [
                        {
                          x: dest.xmin,
                          y: dest.ymin
                        }, {
                          x: dest.xmin,
                          y: dest.ymax
                        }, {
                          x: dest.xmax,
                          y: dest.ymin
                        }
                      ];
                    })(),
                    polynomialOrder: 1,
                    spatialReference: src.spatialReference
                  }
                }
              ])
            },
            handleAs: "json",
            load: function() {
              return request({
                url: _this.imageServiceUrl + "/query",
                content: {
                  objectIds: _this.currentId,
                  returnGeometry: true,
                  outFields: "",
                  f: "json"
                },
                handleAs: "json",
                load: function(response3) {
                  return _this.map.setExtent(new Polygon(response3.features[0].geometry).getExtent().expand(2));
                },
                error: console.error
              });
            },
            error: console.error
          }, {
            usePost: true
          });
        },
        error: console.error
      }, {
        usePost: true
      });
    },
    computeAndTransform: function() {
      var _this = this;

      if (this.currentId == null) {
        return console.error("An image must be uploaded in step 1.");
      }
      return request({
        url: this.imageServiceUrl + ("/" + this.currentId + "/info"),
        content: {
          f: "json"
        },
        handleAs: "json",
        load: function(response1) {
          var src;

          src = response1.extent;
          return request({
            url: _this.imageServiceUrl + "/computeTiePoints",
            content: {
              f: "json",
              rasterId: _this.currentId,
              geodataTransforms: JSON.stringify([
                {
                  geodataTransform: "Identity",
                  geodataTransformArguments: {
                    spatialReference: src.spatialReference
                  }
                }
              ])
            },
            handleAs: "json",
            load: function(response2) {
              var i;

              return long(i = 234);
            },
            error: console.error
          }, {
            usePost: true
          });
        },
        error: console.error
      }, {
        usePost: true
      });
    }
  });
});

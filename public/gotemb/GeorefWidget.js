// Generated by CoffeeScript 1.6.2
var extend;

extend = function(obj, mixin) {
  var method, name;

  for (name in mixin) {
    method = mixin[name];
    obj[name] = method;
  }
  return obj;
};

define(["dojo/_base/declare", "dijit/_WidgetBase", "dijit/_TemplatedMixin", "dijit/_WidgetsInTemplateMixin", "dojo/text!./GeorefWidget/templates/GeorefWidget.html", "dojo/_base/connect", "esri/layers/ArcGISImageServiceLayer", "esri/request", "esri/layers/MosaicRule", "esri/geometry/Polygon", "esri/tasks/GeometryService", "dojo/dom-style", "gotemb/GeorefWidget/PointGrid", "dojo/store/Observable", "dojo/store/Memory", "gotemb/GeorefWidget/TiepointsGrid", "esri/layers/GraphicsLayer", "dojo/_base/Color", "esri/symbols/SimpleMarkerSymbol", "esri/symbols/SimpleLineSymbol", "esri/graphic", "esri/geometry/Point", "dojo/window", "dojo/dom-class", "dojo/query", "dojox/form/FileInput", "dijit/form/Button", "dijit/form/DropDownButton", "dijit/layout/AccordionContainer", "dijit/layout/ContentPane", "gotemb/GeorefWidget/RastersGrid", "dijit/Dialog", "dijit/Toolbar", "dijit/ToolbarSeparator", "dijit/form/ToggleButton", "dijit/Menu", "dijit/MenuItem", "dijit/CheckedMenuItem", "dojo/NodeList-traverse", "dojo/NodeList-dom"], function(declare, _WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin, template, _arg, ArcGISImageServiceLayer, request, MosaicRule, Polygon, GeometryService, domStyle, PointGrid, Observable, Memory, TiepointsGrid, GraphicsLayer, Color, SimpleMarkerSymbol, SimpleLineSymbol, Graphic, Point, win, domClass, query) {
  var connect, disconnect;

  connect = _arg.connect, disconnect = _arg.disconnect;
  return declare([_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin], {
    templateString: template,
    baseClass: "ClassifyWidget",
    map: null,
    imageFile: null,
    uploadForm: null,
    imageServiceUrl: "http://eg1109:6080/arcgis/rest/services/amberg_wgs/ImageServer",
    imageServiceLayer: null,
    referenceLayerUrl: "http://eg1109:6080/arcgis/rest/services/amberg_wgs_reference/ImageServer",
    referenceLayer: null,
    geometryServiceUrl: "http://lamborghini:6080/arcgis/rest/services/Utilities/Geometry/GeometryServer",
    geometryService: null,
    rastertype: null,
    currentId: null,
    rasters: null,
    rastersGrid: null,
    addRasterDialog: null,
    selectRasterContainer: null,
    tasksContainer: null,
    editTiepointsContainer: null,
    editTiepointsContainer_loading: null,
    tiepoints: null,
    tiepointsGrid: null,
    toggleTiepointsSelectionMenuItem: null,
    tiepointsLayer: null,
    rasters_toggleReferenceLayersButton: null,
    editTiepoints_toggleReferenceLayerButton: null,
    editTiepoints_toggleRasterLayerButton: null,
    tiepointsContextMenu: null,
    resetTiepointMenuItem: null,
    mouseTip: null,
    addTiepointButton: null,
    removeSelectedTiepointsMenuItem: null,
    resetSelectedTiepointsMenuItem: null,
    sourceSymbol: new SimpleMarkerSymbol(SimpleMarkerSymbol.STYLE_X, 10, new SimpleLineSymbol(SimpleLineSymbol.STYLE_SOLID, new Color([20, 20, 180]), 2), new Color([0, 0, 0])),
    targetSymbol: new SimpleMarkerSymbol(SimpleMarkerSymbol.STYLE_X, 10, new SimpleLineSymbol(SimpleLineSymbol.STYLE_SOLID, new Color([180, 20, 20]), 2), new Color([0, 0, 0])),
    postCreate: function() {
      var _this = this;

      this.imageServiceLayer = new ArcGISImageServiceLayer(this.imageServiceUrl);
      this.geometryService = new GeometryService(this.geometryServiceUrl);
      return connect(this.imageServiceLayer, "onLoad", function() {
        _this.map.addLayer(_this.referenceLayer = new ArcGISImageServiceLayer(_this.referenceLayerUrl));
        _this.imageServiceLayer.setOpacity(0);
        _this.map.addLayer(_this.imageServiceLayer);
        _this.rastersGrid.set("columns", [
          {
            label: "Raster Id",
            field: "rasterId",
            sortable: false
          }, {
            label: "Name",
            field: "name",
            sortable: false
          }
        ]);
        _this.rastersGrid.set("selectionMode", "single");
        _this.loadRastersList();
        _this.rastersGrid.on("dgrid-select", function(_arg1) {
          var rows;

          rows = _arg1.rows;
          if (_this.currentId === rows[0].data.rasterId) {
            return;
          }
          _this.currentId = rows[0].data.rasterId;
          _this.imageServiceLayer.setMosaicRule(extend(new MosaicRule, {
            method: MosaicRule.METHOD_LOCKRASTER,
            lockRasterIds: [_this.currentId]
          }), true);
          return request({
            url: _this.imageServiceUrl + "/query",
            content: {
              objectIds: [_this.currentId],
              returnGeometry: true,
              outFields: "",
              f: "json"
            },
            handleAs: "json",
            load: function(response3) {
              _this.map.setExtent(new Polygon(response3.features[0].geometry).getExtent().expand(2));
              _this.imageServiceLayer.setOpacity(1);
              return domStyle.set(_this.tasksContainer.domNode, "display", "block");
            },
            error: console.error
          }, {
            usePost: true
          });
        });
        _this.tiepoints = new Observable(new Memory({
          idProperty: "id"
        }));
        _this.tiepointsGrid = new TiepointsGrid({
          columns: [
            {
              label: " ",
              field: "id",
              sortable: false
            }, {
              label: "Source Point",
              field: "sourcePoint",
              sortable: false,
              renderCell: function(object, value, domNode) {
                var pointGrid;

                pointGrid = new PointGrid({
                  x: value.geometry.x,
                  y: value.geometry.y,
                  onPointChanged: function(_arg1) {
                    var point, x, y;

                    x = _arg1.x, y = _arg1.y;
                    point = new Point(value.geometry);
                    point.x = x;
                    point.y = y;
                    return value.setGeometry(point);
                  }
                });
                value.pointChanged = function() {
                  return pointGrid.setPoint({
                    x: value.geometry.x,
                    y: value.geometry.y
                  });
                };
                value.gotoPointGrid = function() {
                  var tdId;

                  win.scrollIntoView(pointGrid.domNode);
                  tdId = new query.NodeList(pointGrid.domNode).parent().parent().children().first();
                  tdId.removeClass("yellow");
                  return setTimeout((function() {
                    return tdId.addClass("yellow");
                  }), 0);
                };
                return pointGrid.domNode;
              }
            }, {
              label: "Target Point",
              field: "targetPoint",
              sortable: false,
              renderCell: function(object, value, domNode) {
                var pointGrid;

                pointGrid = new PointGrid({
                  x: value.geometry.x,
                  y: value.geometry.y,
                  onPointChanged: function(_arg1) {
                    var point, x, y;

                    x = _arg1.x, y = _arg1.y;
                    point = new Point(value.geometry);
                    point.x = x;
                    point.y = y;
                    return value.setGeometry(point);
                  }
                });
                value.pointChanged = function() {
                  return pointGrid.setPoint({
                    x: value.geometry.x,
                    y: value.geometry.y
                  });
                };
                value.gotoPointGrid = function() {
                  var tdId;

                  win.scrollIntoView(pointGrid.domNode);
                  tdId = new query.NodeList(pointGrid.domNode).parent().parent().children().first();
                  tdId.removeClass("yellow");
                  return setTimeout((function() {
                    return tdId.addClass("yellow");
                  }), 0);
                };
                return pointGrid.domNode;
              }
            }
          ],
          store: _this.tiepoints,
          selectionMode: "none"
        }, _this.tiepointsGrid);
        _this.tiepointsGrid.startup();
        _this.tiepointsGrid.on(".field-id:click", function(e) {
          var row;

          if (_this.tiepointsGrid.isSelected(row = _this.tiepointsGrid.cell(e).row)) {
            return _this.tiepointsGrid.deselect(row);
          } else {
            return _this.tiepointsGrid.select(row);
          }
        });
        _this.tiepointsGrid.on("dgrid-select", function(_arg1) {
          var row, rows, _i, _len, _results;

          rows = _arg1.rows;
          _this.toggleTiepointsSelectionMenuItem.set("label", "Clear Selection");
          domStyle.set(_this.removeSelectedTiepointsMenuItem.domNode, "display", "table-row");
          _results = [];
          for (_i = 0, _len = rows.length; _i < _len; _i++) {
            row = rows[_i];
            if (row.data.original != null) {
              domStyle.set(_this.resetSelectedTiepointsMenuItem.domNode, "display", "table-row");
            }
            row.data.sourcePoint.show();
            _results.push(row.data.targetPoint.show());
          }
          return _results;
        });
        _this.tiepointsGrid.on("dgrid-deselect", function(_arg1) {
          var bool, noneSelected, row, rowId, rows, showReset, _i, _len, _ref, _results;

          rows = _arg1.rows;
          _ref = _this.tiepointsGrid.selection;
          for (rowId in _ref) {
            bool = _ref[rowId];
            if (!(bool)) {
              continue;
            }
            noneSelected = false;
            if (_this.tiepointsGrid.row(rowId).data.original != null) {
              showReset = true;
            }
          }
          if (!((noneSelected != null) && !noneSelected)) {
            _this.toggleTiepointsSelectionMenuItem.set("label", "Select All");
            domStyle.set(_this.removeSelectedTiepointsMenuItem.domNode, "display", "none");
          }
          if (!showReset) {
            domStyle.set(_this.resetSelectedTiepointsMenuItem.domNode, "display", "none");
          }
          _results = [];
          for (_i = 0, _len = rows.length; _i < _len; _i++) {
            row = rows[_i];
            row.data.sourcePoint.hide();
            _results.push(row.data.targetPoint.hide());
          }
          return _results;
        });
        _this.tiepointsLayer = new GraphicsLayer;
        _this.map.addLayer(_this.tiepointsLayer);
        connect(_this.tiepointsLayer, "onMouseDown", function(e) {
          _this.map.disablePan();
          _this.graphicBeingMoved = e.graphic;
          return _this.graphicBeingMoved.gotoPointGrid();
        });
        connect(_this.tiepointsLayer, "onClick onDblClick", function(e) {
          delete _this.graphicBeingMoved;
          return _this.map.enablePan();
        });
        connect(_this.map, "onMouseDrag", function(e) {
          if (_this.graphicBeingMoved == null) {
            return;
          }
          _this.graphicBeingMoved.setGeometry(e.mapPoint);
          return _this.graphicBeingMoved.pointChanged();
        });
        return connect(_this.map, "onMouseDragEnd", function(e) {
          if (_this.graphicBeingMoved == null) {
            return;
          }
          _this.graphicBeingMoved.setGeometry(e.mapPoint);
          _this.graphicBeingMoved.pointChanged();
          delete _this.graphicBeingMoved;
          return _this.map.enablePan();
        });
      });
    },
    loadRastersList: function(callback) {
      var _this = this;

      return request({
        url: this.imageServiceUrl + "/query",
        content: {
          f: "json",
          outFields: "OBJECTID, Name"
        },
        handlesAs: "json",
        load: function(response) {
          var feature;

          _this.rasters = (function() {
            var _i, _len, _ref, _results;

            _ref = response.features;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              feature = _ref[_i];
              _results.push({
                rasterId: feature.attributes.OBJECTID,
                name: feature.attributes.Name,
                spatialReference: feature.geometry.spatialReference
              });
            }
            return _results;
          })();
          _this.rastersGrid.refresh();
          _this.rastersGrid.renderArray(_this.rasters);
          return typeof callback === "function" ? callback() : void 0;
        },
        error: console.error
      }, {
        usePost: true
      });
    },
    showAddRasterDialog: function() {
      return this.addRasterDialog.show();
    },
    addRasterDialog_upload: function() {
      var _this = this;

      if (this.imageFile.value.length === 0) {
        return console.error("An image must be selected!");
      }
      this.rastertype = this.imageFile.value.indexOf("las") === -1 ? "Raster Dataset" : "HillshadedLAS";
      console.info("Step 1/3: Uploading...");
      return request({
        url: this.imageServiceUrl + "/uploads/upload",
        form: this.uploadForm,
        content: {
          f: "json"
        },
        handleAs: "json",
        timeout: 600000,
        load: function(response1) {
          if (!response1.success) {
            return console.error("Unsuccessful upload:\n" + response1);
          }
          console.info("Step 2/3: Uploaded, processing the image on server side...");
          return request({
            url: _this.imageServiceUrl + "/add",
            content: {
              itemIds: response1.item.itemID,
              rasterType: _this.rastertype,
              minimumCellSizeFactor: 0.1,
              maximumCellSizeFactor: 10,
              f: "json"
            },
            handleAs: "json",
            load: function(response2) {
              var id;

              if (id = response2.addResults[0].rasterId) {
                return _this.loadRastersList(function() {
                  _this.addRasterDialog.hide();
                  _this.rastersGrid.clearSelection();
                  if (_this.rasters.length > 0) {
                    return _this.rastersGrid.select(_this.rasters.length - 1);
                  }
                });
              }
            },
            error: console.error
          }, {
            usePost: true
          });
        },
        error: console.error
      }, {
        usePost: true
      });
    },
    roughTransform: function() {
      var _this = this;

      if (this.currentId == null) {
        return console.error("No raster selected");
      }
      return request({
        url: this.imageServiceUrl + ("/" + this.currentId + "/info"),
        content: {
          f: "json"
        },
        handleAs: "json",
        load: function(response1) {
          var src;

          src = response1.extent;
          return request({
            url: _this.imageServiceUrl + "/update",
            content: {
              f: "json",
              rasterId: _this.currentId,
              geodataTransforms: JSON.stringify([
                {
                  geodataTransform: "Polynomial",
                  geodataTransformArguments: {
                    sourcePoints: [
                      {
                        x: src.xmin,
                        y: src.ymin
                      }, {
                        x: src.xmin,
                        y: src.ymax
                      }, {
                        x: src.xmax,
                        y: src.ymin
                      }
                    ],
                    targetPoints: (function() {
                      var aspectRatio, dest, map;

                      aspectRatio = (src.xmax - src.xmin) / (src.ymax - src.ymin);
                      map = {
                        width: _this.map.extent.getWidth(),
                        height: _this.map.extent.getHeight(),
                        center: _this.map.extent.getCenter().toJson()
                      };
                      dest = {
                        width: Math.min(map.width, map.height * aspectRatio),
                        height: Math.min(map.height, map.width / aspectRatio)
                      };
                      dest.xmin = map.center.x - dest.width / 2;
                      dest.xmax = map.center.x + dest.width / 2;
                      dest.ymin = map.center.y - dest.height / 2;
                      dest.ymax = map.center.y + dest.height / 2;
                      return [
                        {
                          x: dest.xmin,
                          y: dest.ymin
                        }, {
                          x: dest.xmin,
                          y: dest.ymax
                        }, {
                          x: dest.xmax,
                          y: dest.ymin
                        }
                      ];
                    })(),
                    polynomialOrder: 1,
                    spatialReference: src.spatialReference
                  }
                }
              ])
            },
            handleAs: "json",
            load: function() {
              return request({
                url: _this.imageServiceUrl + "/query",
                content: {
                  objectIds: _this.currentId,
                  returnGeometry: true,
                  outFields: "",
                  f: "json"
                },
                handleAs: "json",
                load: function(response3) {
                  return _this.map.setExtent(new Polygon(response3.features[0].geometry).getExtent().expand(2));
                },
                error: console.error
              }, {
                usePost: true
              });
            },
            error: console.error
          }, {
            usePost: true
          });
        },
        error: console.error
      }, {
        usePost: true
      });
    },
    computeAndTransform: function() {
      var _this = this;

      return this.computeTiePoints(function(_arg1) {
        var tiePoints;

        tiePoints = _arg1.tiePoints;
        return _this.applyTransform(tiePoints);
      });
    },
    applyTransform: function(tiePoints, callback) {
      var point,
        _this = this;

      return request({
        url: this.imageServiceUrl + "/update",
        content: {
          f: "json",
          rasterId: this.currentId,
          geodataTransforms: JSON.stringify([
            {
              geodataTransform: "Polynomial",
              geodataTransformArguments: {
                sourcePoints: (function() {
                  var _i, _len, _ref, _results;

                  _ref = tiePoints.sourcePoints;
                  _results = [];
                  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                    point = _ref[_i];
                    _results.push({
                      x: point.x,
                      y: point.y
                    });
                  }
                  return _results;
                })(),
                targetPoints: (function() {
                  var _i, _len, _ref, _results;

                  _ref = tiePoints.targetPoints;
                  _results = [];
                  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                    point = _ref[_i];
                    _results.push({
                      x: point.x,
                      y: point.y
                    });
                  }
                  return _results;
                })(),
                polynomialOrder: 1,
                spatialReference: tiePoints.sourcePoints[0].spatialReference
              }
            }
          ])
        },
        handleAs: "json",
        load: function() {
          return request({
            url: _this.imageServiceUrl + "/query",
            content: {
              objectIds: _this.currentId,
              returnGeometry: true,
              outFields: "",
              f: "json"
            },
            handleAs: "json",
            load: function(response2) {
              _this.map.setExtent(new Polygon(response2.features[0].geometry).getExtent().expand(2));
              return typeof callback === "function" ? callback() : void 0;
            },
            error: console.error
          });
        },
        error: console.error
      }, {
        usePost: true
      });
    },
    computeTiePoints: function(callback) {
      var _this = this;

      return request({
        url: this.imageServiceUrl + "/computeTiePoints",
        content: {
          f: "json",
          rasterId: this.currentId,
          geodataTransforms: JSON.stringify([
            {
              geodataTransform: "Identity",
              geodataTransformArguments: {
                spatialReference: this.rasters.filter(function(x) {
                  return x.rasterId === _this.currentId;
                })[0].spatialReference
              }
            }
          ])
        },
        handleAs: "json",
        load: function(response) {
          return typeof callback === "function" ? callback(response) : void 0;
        },
        error: console.error
      }, {
        usePost: true
      });
    },
    toggleReferenceLayer: function(state) {
      this.referenceLayer.setOpacity(state ? 1 : 0);
      this.rasters_toggleReferenceLayersButton.set("checked", state);
      return this.editTiepoints_toggleReferenceLayerButton.set("checked", state);
    },
    toggleRasterLayer: function(state) {
      return this.imageServiceLayer.setOpacity(state ? 1 : 0);
    },
    startEditTiepoints: function() {
      var container, containers, display, _i, _len, _ref,
        _this = this;

      domStyle.set(this.editTiepointsContainer_loading, "display", "block");
      _ref = {
        none: [this.selectRasterContainer, this.tasksContainer],
        block: [this.editTiepointsContainer]
      };
      for (display in _ref) {
        containers = _ref[display];
        for (_i = 0, _len = containers.length; _i < _len; _i++) {
          container = containers[_i];
          domStyle.set(container.domNode, "display", display);
        }
      }
      return this.computeTiePoints(function(_arg1) {
        var i, sourcePoint, targetPoint, tiePoints, _j, _ref1;

        tiePoints = _arg1.tiePoints;
        domStyle.set(_this.editTiepointsContainer_loading, "display", "none");
        for (i = _j = 0, _ref1 = tiePoints.sourcePoints.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
          _this.tiepoints.put({
            id: i + 1,
            sourcePoint: sourcePoint = new Graphic(new Point(tiePoints.sourcePoints[i]), _this.sourceSymbol),
            targetPoint: targetPoint = new Graphic(new Point(tiePoints.targetPoints[i]), _this.targetSymbol),
            original: {
              sourcePoint: new Point(tiePoints.sourcePoints[i]),
              targetPoint: new Point(tiePoints.targetPoints[i])
            }
          });
          _this.tiepointsLayer.add(sourcePoint);
          _this.tiepointsLayer.add(targetPoint);
        }
        return _this.tiepointsGrid.selectAll();
      });
    },
    closeEditTiepoints: function() {
      var container, containers, display, tiepoint, _i, _len, _ref, _ref1, _results;

      domStyle.set(this.editTiepointsContainer_loading, "display", "none");
      this.tiepointsLayer.clear();
      _ref = this.tiepoints.data.splice(0);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        tiepoint = _ref[_i];
        this.tiepoints.remove(tiepoint.id);
      }
      _ref1 = {
        block: [this.selectRasterContainer, this.tasksContainer],
        none: [this.editTiepointsContainer]
      };
      _results = [];
      for (display in _ref1) {
        containers = _ref1[display];
        _results.push((function() {
          var _j, _len1, _results1;

          _results1 = [];
          for (_j = 0, _len1 = containers.length; _j < _len1; _j++) {
            container = containers[_j];
            _results1.push(domStyle.set(container.domNode, "display", display));
          }
          return _results1;
        })());
      }
      return _results;
    },
    toggleTiepointsSelection: function() {
      if (this.toggleTiepointsSelectionMenuItem.label === "Clear Selection") {
        return this.tiepointsGrid.clearSelection();
      } else {
        return this.tiepointsGrid.selectAll();
      }
    },
    tiepointsContextMenuOpen: function() {
      return domStyle.set(this.resetTiepointMenuItem.domNode, "display", this.tiepointsGrid.cell(this.tiepointsContextMenu.currentTarget).row.data.original != null ? "table-row" : "none");
    },
    removeTiepoint: function() {
      var graphic, tiepoint, _i, _len, _ref, _results;

      this.tiepoints.remove((tiepoint = this.tiepointsGrid.cell(this.tiepointsContextMenu.currentTarget).row.data).id);
      _ref = [tiepoint.sourcePoint, tiepoint.targetPoint];
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        graphic = _ref[_i];
        _results.push(this.tiepointsLayer.remove(graphic));
      }
      return _results;
    },
    resetTiepoint: function() {
      var key, tiepoint, _i, _len, _ref, _results;

      tiepoint = this.tiepointsGrid.cell(this.tiepointsContextMenu.currentTarget).row.data;
      _ref = ["sourcePoint", "targetPoint"];
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        key = _ref[_i];
        tiepoint[key].setGeometry(tiepoint.original[key]);
        _results.push(tiepoint[key].pointChanged());
      }
      return _results;
    },
    addTiepoint: function(state) {
      var closeMouseTip, currentState, mapDownEvent, mapDragEvent, mapUpEvent, mouseTipDownEvent, mouseTipMoveEvent, sourcePoint, targetPoint,
        _this = this;

      console.log("AddTiepointButton: " + state);
      if (state) {
        currentState = "started";
        this.map.setMapCursor("crosshair");
        sourcePoint = null;
        targetPoint = null;
        this.mouseTip.innerText = "Click to place Source Point on the map.";
        mouseTipMoveEvent = connect(query("body")[0], "onmousemove", function(e) {
          domStyle.set(_this.mouseTip, "display", "block");
          domStyle.set(_this.mouseTip, "left", e.clientX + 20 + "px");
          return domStyle.set(_this.mouseTip, "top", e.clientY + 20 + "px");
        });
        mouseTipDownEvent = connect(query("body")[0], "onmousedown", function(e) {
          var point, _i, _len, _ref;

          console.log("Body: MouseDown");
          if (currentState === "placingSourcePoint") {
            return currentState = "placingSourcePoint.1";
          }
          if (currentState === "placingTargetPoint") {
            return currentState = "placingTargetPoint.1";
          }
          if (typeof closeMouseTip === "function") {
            closeMouseTip();
          }
          _ref = [sourcePoint, targetPoint];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            point = _ref[_i];
            _this.tiepointsLayer.remove(point);
          }
          if (!_this.addTiepointButton.hovering) {
            return _this.addTiepointButton.set("checked", false);
          }
        });
        mapDownEvent = connect(this.map, "onMouseDown", function(e) {
          console.log("Map: MouseDown");
          return currentState = (function() {
            switch (currentState) {
              case "started":
                return "placingSourcePoint";
              case "placedSourcePoint":
                return "placingTargetPoint";
              default:
                return currentState;
            }
          })();
        });
        mapUpEvent = connect(this.map, "onMouseUp", function(e) {
          var lastId, tiepoint;

          console.log("Map: MouseUp");
          if (currentState === "placingSourcePoint.1") {
            currentState = "placedSourcePoint";
            sourcePoint = new Graphic(e.mapPoint, _this.sourceSymbol);
            _this.tiepointsLayer.add(sourcePoint);
            return _this.mouseTip.innerText = "Click to place Target Point on the map.";
          } else if (currentState === "placingTargetPoint.1") {
            currentState = "placedTargetPoint";
            targetPoint = new Graphic(e.mapPoint, _this.targetSymbol);
            _this.tiepointsLayer.add(targetPoint);
            _this.tiepoints.put(tiepoint = {
              id: lastId = Math.max.apply(Math, _this.tiepoints.data.map(function(x) {
                return x.id;
              }).concat(0)) + 1,
              sourcePoint: sourcePoint,
              targetPoint: targetPoint
            });
            _this.tiepointsGrid.select(tiepoint);
            closeMouseTip();
            return _this.addTiepointButton.set("checked", false);
          }
        });
        mapDragEvent = connect(this.map, "onMouseDrag", function(e) {
          console.log("Map: MouseDrag");
          return currentState = (function() {
            switch (currentState) {
              case "placingSourcePoint.1":
                return "started";
              case "placingTargetPoint.1":
                return "placingTargetPoint";
              default:
                return currentState;
            }
          })();
        });
        return closeMouseTip = function() {
          disconnect(mouseTipMoveEvent);
          disconnect(mouseTipDownEvent);
          disconnect(mapDownEvent);
          disconnect(mapUpEvent);
          disconnect(mapDragEvent);
          domStyle.set(_this.mouseTip, "display", "none");
          _this.mouseTip.innerText = "...";
          _this.map.setMapCursor("default");
          return currentState = "placedTiepoint";
        };
      }
    },
    removeSelectedTiepoints: function() {
      var bool, graphic, rowId, tiepoint, _ref, _results;

      _ref = this.tiepointsGrid.selection;
      _results = [];
      for (rowId in _ref) {
        bool = _ref[rowId];
        if (!(bool)) {
          continue;
        }
        this.tiepoints.remove((tiepoint = this.tiepointsGrid.row(rowId).data).id);
        _results.push((function() {
          var _i, _len, _ref1, _results1;

          _ref1 = [tiepoint.sourcePoint, tiepoint.targetPoint];
          _results1 = [];
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            graphic = _ref1[_i];
            _results1.push(this.tiepointsLayer.remove(graphic));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    },
    resetSelectedTiepoints: function() {
      var bool, key, rowId, tiepoint, _ref, _results;

      _ref = this.tiepointsGrid.selection;
      _results = [];
      for (rowId in _ref) {
        bool = _ref[rowId];
        if (!(bool)) {
          continue;
        }
        tiepoint = this.tiepointsGrid.row(rowId).data;
        if (tiepoint.original == null) {
          continue;
        }
        _results.push((function() {
          var _i, _len, _ref1, _results1;

          _ref1 = ["sourcePoint", "targetPoint"];
          _results1 = [];
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            key = _ref1[_i];
            tiepoint[key].setGeometry(tiepoint.original[key]);
            _results1.push(tiepoint[key].pointChanged());
          }
          return _results1;
        })());
      }
      return _results;
    },
    applyManualTransform: function() {
      var _this = this;

      return this.applyTransform({
        sourcePoints: this.tiepoints.data.map(function(x) {
          return x.sourcePoint.geometry.toJson();
        }),
        targetPoints: this.tiepoints.data.map(function(x) {
          return x.targetPoint.geometry.toJson();
        })
      }, function() {
        return _this.closeEditTiepoints();
      });
    }
  });
});

// Generated by CoffeeScript 1.6.2
var __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

(function() {
  var extend;

  extend = function(obj, mixin) {
    var method, name;

    for (name in mixin) {
      method = mixin[name];
      obj[name] = method;
    }
    return obj;
  };
  return define(["dojo/_base/declare", "dijit/_WidgetBase", "dijit/_TemplatedMixin", "dijit/_WidgetsInTemplateMixin", "dojo/text!./GeorefWidget/templates/GeorefWidget.html", "dojo/_base/connect", "esri/layers/ArcGISImageServiceLayer", "esri/request", "esri/layers/MosaicRule", "esri/geometry/Polygon", "esri/tasks/GeometryService", "dojo/dom-style", "gotemb/GeorefWidget/PointGrid", "dojo/store/Observable", "dojo/store/Memory", "gotemb/GeorefWidget/TiepointsGrid", "esri/layers/GraphicsLayer", "dojo/_base/Color", "esri/symbols/SimpleMarkerSymbol", "esri/symbols/SimpleLineSymbol", "esri/graphic", "esri/geometry/Point", "dojo/window", "dojo/dom-class", "dojo/query", "dgrid/editor", "gotemb/GeorefWidget/RastersGrid", "esri/geometry/Extent", "esri/tasks/ProjectParameters", "esri/SpatialReference", "dojo/_base/url", "esri/layers/ArcGISTiledMapServiceLayer", "gotemb/GeorefWidget/AsyncResultsGrid", "dijit/popup", "dijit/form/CheckBox", "dojo/aspect", "esri/layers/ImageServiceParameters", "esri/layers/RasterFunction", "socket.io/socket.io", "dojox/form/FileInput", "dijit/form/Button", "dijit/form/DropDownButton", "dijit/layout/AccordionContainer", "dijit/layout/ContentPane", "dijit/Dialog", "dijit/Toolbar", "dijit/ToolbarSeparator", "dijit/form/ToggleButton", "dijit/Menu", "dijit/MenuItem", "dijit/CheckedMenuItem", "dojo/NodeList-traverse", "dojo/NodeList-dom", "dijit/TooltipDialog", "dijit/Tooltip", "eligrey/FileSaver"], function(declare, _WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin, template, _arg, ArcGISImageServiceLayer, request, MosaicRule, Polygon, GeometryService, domStyle, PointGrid, Observable, Memory, TiepointsGrid, GraphicsLayer, Color, SimpleMarkerSymbol, SimpleLineSymbol, Graphic, Point, win, domClass, query, editor, RastersGrid, Extent, ProjectParameters, SpatialReference, Url, ArcGISTiledMapServiceLayer, AsyncResultsGrid, popup, CheckBox, aspect, ImageServiceParameters, RasterFunction, io) {
    var connect, disconnect;

    connect = _arg.connect, disconnect = _arg.disconnect;
    return declare([_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin], {
      templateString: template,
      baseClass: "GeorefWidget",
      map: null,
      imageFile: null,
      uploadForm: null,
      imageServiceUrl: "http://eg1109.uae.esri.com:6080/arcgis/rest/services/ISERV/ImageServer",
      imageServiceLayer: null,
      geometryServiceUrl: "http://tasks.arcgisonline.com/arcgis/rest/services/Geometry/GeometryServer",
      geometryService: null,
      rastertype: null,
      currentId: null,
      rastersArchive: null,
      rasters: null,
      rastersGrid: null,
      addRasterDialog: null,
      selectRasterContainer: null,
      tasksContainer: null,
      editTiepointsContainer: null,
      tiepoints: null,
      tiepointsGrid: null,
      toggleTiepointsSelectionMenuItem: null,
      tiepointsLayer: null,
      tiepointsContextMenu: null,
      resetTiepointMenuItem: null,
      mouseTip: null,
      addTiepointButton: null,
      removeSelectedTiepointsMenuItem: null,
      resetSelectedTiepointsMenuItem: null,
      manualTransformContainer: null,
      rtMoveContainer: null,
      rtMoveFromGrid: null,
      rtMoveToGrid: null,
      rt_moveButton: null,
      rt_scaleButton: null,
      rt_rotateButton: null,
      rtMoveFromPickButton: null,
      rtMoveToPickButton: null,
      miscGraphicsLayer: null,
      rtScaleContainer: null,
      rtScaleFactorInput: null,
      rtRotateContainer: null,
      rtRotateDegreesInput: null,
      rasterNotSelectedDialog: null,
      selectBasemap_SatelliteButton: null,
      selectBasemap_HybridButton: null,
      selectBasemap_TopographicButton: null,
      selectBasemap_StreetsButton: null,
      selectBasemap_NaturalVueButton: null,
      naturalVueServiceUrl: "http://raster.arcgisonline.com/ArcGIS/rest/services/MDA_NaturalVue_Imagery_cached/MapServer",
      naturalVueServiceLayer: null,
      asyncResultsContainer: null,
      asyncResults: null,
      asyncResultsGrid: null,
      asyncTaskDetailsPopup: null,
      atdpResultId: null,
      atdpTask: null,
      atdpRasterId: null,
      atdpStatus: null,
      atdpStartTime: null,
      atdpEndTime: null,
      atdpTime: null,
      atdpStartTimeTr: null,
      atdpEndTimeTr: null,
      atdpTimeTr: null,
      atdpContinueEvent: null,
      atdpContinueButton: null,
      confirmActionPopup: null,
      confirmActionPopupContinueEvent: null,
      collectComputedTiepointsButton: null,
      computeAndTransformButton: null,
      loadingGif: null,
      toggleRasterLayerButton: null,
      toggleFootprintsButton: null,
      setImageFormat_JPGPNGButton: null,
      setImageFormat_JPGButton: null,
      rastersDisplayMenu: null,
      applyManualTransform_ProjectiveButton: null,
      applyManualTransform_1stOrderButton: null,
      applyManualTransform_2ndOrderButton: null,
      applyManualTransform_3rdOrderButton: null,
      applyManualTransform_ProjectiveTooltip: null,
      applyManualTransform_1stOrderTooltip: null,
      applyManualTransform_2ndOrderTooltip: null,
      applyManualTransform_3rdOrderTooltip: null,
      footprintsLayer: null,
      georefStatus_CompleteButton: null,
      georefStatus_FalseButton: null,
      georefStatus_PartialButton: null,
      georefStatus_WIPButton: null,
      georefStatusDropButton: null,
      markGeoreferencedButton: null,
      openRoughTransformButton: null,
      startEditTiepointsButton: null,
      socket: null,
      wipRasters: null,
      sourceSymbol: (function() {
        var symbol;

        symbol = new SimpleMarkerSymbol(SimpleMarkerSymbol.STYLE_X, 10, new SimpleLineSymbol(SimpleLineSymbol.STYLE_SOLID, new Color([255, 255, 255, 0.5]), 1), new Color([20, 20, 180]));
        symbol.setPath("M -7 -5\nL -5 -7\nL  0 -2\nL  5 -7\nL  7 -5\nL  2  0\nL  7  5\nL  5  7\nL  0  2\nL -5  7\nL -7  5\nL -2  0\nL -7 -5\nZ");
        return symbol;
      })(),
      targetSymbol: (function() {
        var symbol;

        symbol = new SimpleMarkerSymbol(SimpleMarkerSymbol.STYLE_X, 10, new SimpleLineSymbol(SimpleLineSymbol.STYLE_SOLID, new Color([255, 255, 255, 0.5]), 1), new Color([180, 20, 20]));
        symbol.setPath("M -7 -5\nL -5 -7\nL  0 -2\nL  5 -7\nL  7 -5\nL  2  0\nL  7  5\nL  5  7\nL  0  2\nL -5  7\nL -7  5\nL -2  0\nL -7 -5\nZ");
        return symbol;
      })(),
      selectedSourceSymbol: (function() {
        var symbol;

        symbol = new SimpleMarkerSymbol(SimpleMarkerSymbol.STYLE_X, 10, new SimpleLineSymbol(SimpleLineSymbol.STYLE_SOLID, new Color([255, 255, 255, 0.5]), 1), new Color([20, 20, 180]));
        symbol.setPath("M -9.5 -6.5\nL -6.5 -9.5\nL  0   -2\nL  6.5 -9.5\nL  9.5 -6.5\nL  2    0\nL  9.5  6.5\nL  6.5  9.5\nL  0    2\nL -6.5  9.5\nL -9.5  6.5\nL -2    0\nL -9.5 -6.5\nZ");
        return symbol;
      })(),
      selectedTargetSymbol: (function() {
        var symbol;

        symbol = new SimpleMarkerSymbol(SimpleMarkerSymbol.STYLE_X, 10, new SimpleLineSymbol(SimpleLineSymbol.STYLE_SOLID, new Color([255, 255, 255, 0.5]), 1), new Color([180, 20, 20]));
        symbol.setPath("M -9.5 -6.5\nL -6.5 -9.5\nL  0   -2\nL  6.5 -9.5\nL  9.5 -6.5\nL  2    0\nL  9.5  6.5\nL  6.5  9.5\nL  0    2\nL -6.5  9.5\nL -9.5  6.5\nL -2    0\nL -9.5 -6.5\nZ");
        return symbol;
      })(),
      footprintSymbol: new SimpleLineSymbol(SimpleLineSymbol.STYLE_SOLID, new Color([10, 240, 10]), 1),
      selectedFootprintSymbol: new SimpleLineSymbol(SimpleLineSymbol.STYLE_SOLID, new Color([10, 240, 240]), 2),
      scrollToElement: function(element) {
        var elemNL, prevNL;

        elemNL = query(element).closest(".dgrid-row");
        if ((prevNL = elemNL.prev()).length === 0 || prevNL[0].classList.contains("dgrid-preload")) {
          elemNL.parent().parent()[0].scrollTop = 0;
        } else {
          win.scrollIntoView(prevNL[0]);
        }
        return win.scrollIntoView(element);
      },
      postCreate: function() {
        var corsEnabledServers, imageServiceAuthority, onceDone,
          _this = this;

        imageServiceAuthority = new Url(this.imageServiceUrl).authority;
        corsEnabledServers = esri.config.defaults.io.corsEnabledServers;
        if (!corsEnabledServers.some(function(x) {
          return x === imageServiceAuthority;
        })) {
          corsEnabledServers.push(imageServiceAuthority);
        }
        this.imageServiceLayer = new ArcGISImageServiceLayer(this.imageServiceUrl, {
          imageServiceParameters: extend(new ImageServiceParameters, {
            renderingRule: extend(new RasterFunction, {
              functionName: "Stretch",
              "arguments": {
                StretchType: 6,
                DRA: true,
                MinPercent: 0,
                MaxPercent: 2
              },
              variableName: "Raster"
            })
          })
        });
        this.imageServiceLayer.setDisableClientCaching(true);
        this.geometryService = new GeometryService(this.geometryServiceUrl);
        onceDone = false;
        return this.watch("map", function(attr, oldMap, newMap) {
          if (onceDone) {
            return;
          } else {
            onceDone = true;
          }
          _this.map.addLayer(_this.imageServiceLayer);
          _this.footprintsLayer = new GraphicsLayer;
          _this.map.addLayer(_this.footprintsLayer);
          _this.rasters = new Observable(new Memory({
            idProperty: "rasterId"
          }));
          _this.rastersGrid = new RastersGrid({
            columns: [
              editor({
                label: " ",
                field: "display",
                editor: CheckBox,
                editorArgs: {
                  title: "Toggle Visibility"
                },
                sortable: false
              }), {
                label: "Id",
                field: "rasterId",
                sortable: false
              }, {
                label: "Name",
                field: "name",
                sortable: false
              }
            ],
            store: _this.rasters,
            selectionMode: "none",
            sort: "rasterId"
          }, _this.rastersGrid);
          _this.rastersGrid.startup();
          domStyle.set(_this.selectRasterContainer.domNode, "display", "block");
          _this.rastersArchive = [];
          _this.loadRastersList(function() {
            _this.refreshMosaicRule();
            return domStyle.set(_this.loadingGif, "display", "none");
          });
          _this.rastersGrid.on(".field-rasterId:click, .field-name:click", function(e) {
            if (_this.rastersGrid.cell(e).row == null) {
              return;
            }
            if (_this.currentGeorefStatus() !== 1) {
              _this.map.setExtent(_this.rastersGrid.cell(e).row.data.footprint.geometry.getExtent());
            }
            if (_this.currentGeorefStatus() === 3) {
              return;
            }
            _this.rastersGrid.clearSelection();
            return _this.rastersGrid.select(_this.rastersGrid.cell(e).row);
          });
          _this.rastersGrid.on("dgrid-select", function(_arg1) {
            var oldId, raster, rows, _i, _len, _ref, _ref1;

            rows = _arg1.rows;
            oldId = _this.currentId;
            _this.currentId = rows[0].data.rasterId;
            _this.scrollToElement(rows[0].element);
            _ref = _this.rasters.data;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              raster = _ref[_i];
              raster.footprint.setSymbol(_this.footprintSymbol);
            }
            rows[0].data.footprint.setSymbol(_this.selectedFootprintSymbol);
            if (oldId !== _this.currentId) {
              if ((oldId != null) && !((_ref1 = _this.rastersArchive[oldId].tiepoints) != null ? _ref1.data.length : void 0) > 0) {
                _this.socket.emit("removeWIP", oldId, function(_arg2) {
                  var success;

                  success = _arg2.success;
                });
              }
              return _this.socket.emit("addWIP", _this.currentId, function(_arg2) {
                var success;

                success = _arg2.success;
              });
            }
          });
          _this.rastersGrid.on("dgrid-datachange", function(_arg1) {
            var cell, value;

            cell = _arg1.cell, value = _arg1.value;
            cell.row.data.display = value;
            return _this.refreshMosaicRule();
          });
          _this.tiepoints = new Observable(new Memory({
            idProperty: "id"
          }));
          _this.tiepointsGrid = new TiepointsGrid({
            columns: [
              {
                label: " ",
                field: "id",
                sortable: false
              }, {
                label: "Source Point",
                field: "sourcePoint",
                sortable: false,
                renderCell: function(object, value, domNode) {
                  var pointGrid;

                  pointGrid = new PointGrid({
                    x: value.geometry.x,
                    y: value.geometry.y,
                    onPointChanged: function(_arg1) {
                      var point, x, y;

                      x = _arg1.x, y = _arg1.y;
                      point = new Point(value.geometry);
                      point.x = x;
                      point.y = y;
                      return value.setGeometry(point);
                    }
                  });
                  value.pointChanged = function() {
                    return pointGrid.setPoint({
                      x: value.geometry.x,
                      y: value.geometry.y
                    });
                  };
                  value.gotoPointGrid = function() {
                    var mouseUpEvent, rowNL;

                    _this.scrollToElement(pointGrid.domNode);
                    rowNL = query(pointGrid.domNode).closest(".dgrid-row");
                    rowNL.addClass("yellow");
                    return mouseUpEvent = connect(_this.tiepointsLayer, "onMouseUp", function() {
                      rowNL.removeClass("yellow");
                      return disconnect(mouseUpEvent);
                    });
                  };
                  return pointGrid.domNode;
                }
              }, {
                label: "Target Point",
                field: "targetPoint",
                sortable: false,
                renderCell: function(object, value, domNode) {
                  var pointGrid;

                  pointGrid = new PointGrid({
                    x: value.geometry.x,
                    y: value.geometry.y,
                    onPointChanged: function(_arg1) {
                      var point, x, y;

                      x = _arg1.x, y = _arg1.y;
                      point = new Point(value.geometry);
                      point.x = x;
                      point.y = y;
                      return value.setGeometry(point);
                    }
                  });
                  value.pointChanged = function() {
                    return pointGrid.setPoint({
                      x: value.geometry.x,
                      y: value.geometry.y
                    });
                  };
                  value.gotoPointGrid = function() {
                    var mouseUpEvent, rowNL;

                    _this.scrollToElement(pointGrid.domNode);
                    rowNL = query(pointGrid.domNode).closest(".dgrid-row");
                    rowNL.addClass("yellow");
                    return mouseUpEvent = connect(_this.tiepointsLayer, "onMouseUp", function() {
                      rowNL.removeClass("yellow");
                      return disconnect(mouseUpEvent);
                    });
                  };
                  return pointGrid.domNode;
                }
              }
            ]
          }, _this.tiepointsGrid);
          _this.tiepointsGrid.startup();
          _this.tiepointsGrid.on("dgrid-select", function(_arg1) {
            var row, rows, _i, _len, _results;

            rows = _arg1.rows;
            _this.toggleTiepointsSelectionMenuItem.set("label", "Clear Selection");
            domStyle.set(_this.removeSelectedTiepointsMenuItem.domNode, "display", "table-row");
            _results = [];
            for (_i = 0, _len = rows.length; _i < _len; _i++) {
              row = rows[_i];
              if (row.data.original != null) {
                domStyle.set(_this.resetSelectedTiepointsMenuItem.domNode, "display", "table-row");
              }
              row.data.sourcePoint.setSymbol(_this.selectedSourceSymbol);
              _results.push(row.data.targetPoint.setSymbol(_this.selectedTargetSymbol));
            }
            return _results;
          });
          _this.tiepointsGrid.on("dgrid-deselect", function(_arg1) {
            var bool, noneSelected, row, rowId, rows, showReset, _i, _len, _ref, _results;

            rows = _arg1.rows;
            _ref = _this.tiepointsGrid.selection;
            for (rowId in _ref) {
              bool = _ref[rowId];
              if (!(bool)) {
                continue;
              }
              noneSelected = false;
              if (_this.tiepointsGrid.row(rowId).data.original != null) {
                showReset = true;
              }
            }
            if (!((noneSelected != null) && !noneSelected)) {
              _this.toggleTiepointsSelectionMenuItem.set("label", "Select All");
              domStyle.set(_this.removeSelectedTiepointsMenuItem.domNode, "display", "none");
            }
            if (!showReset) {
              domStyle.set(_this.resetSelectedTiepointsMenuItem.domNode, "display", "none");
            }
            _results = [];
            for (_i = 0, _len = rows.length; _i < _len; _i++) {
              row = rows[_i];
              row.data.sourcePoint.setSymbol(_this.sourceSymbol);
              _results.push(row.data.targetPoint.setSymbol(_this.targetSymbol));
            }
            return _results;
          });
          _this.tiepointsLayer = new GraphicsLayer;
          _this.map.addLayer(_this.tiepointsLayer);
          _this.miscGraphicsLayer = new GraphicsLayer;
          _this.map.addLayer(_this.miscGraphicsLayer);
          connect(_this.tiepointsLayer, "onMouseDown", function(e) {
            var _base;

            _this.map.disablePan();
            _this.graphicBeingMoved = e.graphic;
            return typeof (_base = _this.graphicBeingMoved).gotoPointGrid === "function" ? _base.gotoPointGrid() : void 0;
          });
          connect(_this.tiepointsLayer, "onClick onDblClick", function(e) {
            delete _this.graphicBeingMoved;
            return _this.map.enablePan();
          });
          connect(_this.miscGraphicsLayer, "onMouseDown", function(e) {
            _this.map.disablePan();
            return _this.graphicBeingMoved = e.graphic;
          });
          connect(_this.miscGraphicsLayer, "onClick onDblClick", function(e) {
            delete _this.graphicBeingMoved;
            return _this.map.enablePan();
          });
          connect(_this.map, "onMouseDrag", function(e) {
            var _base;

            if (_this.graphicBeingMoved == null) {
              return;
            }
            _this.graphicBeingMoved.setGeometry(e.mapPoint);
            return typeof (_base = _this.graphicBeingMoved).pointChanged === "function" ? _base.pointChanged() : void 0;
          });
          connect(_this.map, "onMouseDragEnd", function(e) {
            var _base;

            if (_this.graphicBeingMoved == null) {
              return;
            }
            _this.graphicBeingMoved.setGeometry(e.mapPoint);
            if (typeof (_base = _this.graphicBeingMoved).pointChanged === "function") {
              _base.pointChanged();
            }
            delete _this.graphicBeingMoved;
            return _this.map.enablePan();
          });
          connect(_this.map, "onClick", function(e) {
            var raster, _i, _ref, _results;

            if (domStyle.get(_this.selectRasterContainer.domNode, "display") !== "block") {
              return;
            }
            if (_this.currentGeorefStatus() === 3) {
              return;
            }
            _ref = _this.rasters.data;
            _results = [];
            for (_i = _ref.length - 1; _i >= 0; _i += -1) {
              raster = _ref[_i];
              if (raster.display) {
                if (raster.footprint.geometry.contains(e.mapPoint)) {
                  _this.rastersGrid.clearSelection();
                  _this.rastersGrid.select(raster);
                  break;
                } else {
                  _results.push(void 0);
                }
              }
            }
            return _results;
          });
          connect(_this.map, "onExtentChange", function(e) {
            if (domStyle.get(_this.selectRasterContainer.domNode, "display") === "none" || _this.georefStatus_FalseButton.domNode.classList.contains("bold")) {
              return;
            }
            return _this.loadRastersList(function() {
              return _this.refreshMosaicRule();
            });
          });
          _this.asyncResults = new Observable(new Memory({
            idProperty: "resultId"
          }));
          _this.asyncResultsGrid = new AsyncResultsGrid({
            columns: [
              {
                label: "Id",
                field: "resultId",
                sortable: false
              }, {
                label: "Task",
                field: "task",
                sortable: false
              }, {
                label: "Status",
                field: "status",
                sortable: false
              }
            ],
            store: _this.asyncResults,
            selectionMode: "none"
          }, _this.asyncResultsGrid);
          _this.asyncResultsGrid.startup();
          _this.asyncResultsGrid.on(".field-resultId:click, .field-task:click, .field-status:click", function(e) {
            _this.asyncResultsGrid.clearSelection();
            return _this.asyncResultsGrid.select(_this.asyncResultsGrid.cell(e).row);
          });
          _this.asyncResultsGrid.on("dgrid-select", function(_arg1) {
            var label, row, value, _ref, _ref1, _ref2;

            row = _arg1.rows[0];
            _ref = {
              atdpResultId: "resultId",
              atdpTask: "task",
              atdpStatus: "status",
              atdpRasterId: "rasterId",
              atdpStartTime: "startTime",
              atdpEndTime: "endTime",
              atdpTime: "time"
            };
            for (label in _ref) {
              value = _ref[label];
              _this[label].innerHTML = (_ref1 = row.data[value]) != null ? _ref1 : "--";
            }
            domStyle.set(_this.atdpContinueButton.domNode, "display", row.data.callback != null ? "inline-block" : "none");
            domStyle.set(_this.atdpRemoveButton.domNode, "display", row.data.status === "Pending" ? "none" : "block");
            if (row.data.time != null) {
              domStyle.set(_this.atdpStartTimeTr, "display", "none");
              domStyle.set(_this.atdpEndTimeTr, "display", "none");
              domStyle.set(_this.atdpTimeTr, "display", "table-row");
            } else {
              domStyle.set(_this.atdpStartTimeTr, "display", "table-row");
              domStyle.set(_this.atdpEndTimeTr, "display", "table-row");
              domStyle.set(_this.atdpTimeTr, "display", "none");
            }
            _this.atdpContinueButton.set("label", (_ref2 = row.data.callbackLabel) != null ? _ref2 : "Continue Task");
            _this.atdpContinueEvent = function() {
              var _base;

              _this.atdpClose();
              if (row.data.rasterId != null) {
                return request({
                  url: _this.imageServiceUrl + "/query",
                  content: {
                    f: "json",
                    where: "OBJECTID = " + row.data.rasterId,
                    returnGeometry: true
                  },
                  handlesAs: "json",
                  load: function(_arg2) {
                    var features, mosaicRefreshedAspect;

                    features = _arg2.features;
                    _this.map.setExtent(new Polygon(features[0].geometry).getExtent());
                    return mosaicRefreshedAspect = aspect.after(_this, "refreshMosaicRule", function() {
                      var selectAspect;

                      if (mosaicRefreshedAspect.done) {
                        return;
                      } else {
                        mosaicRefreshedAspect.done = true;
                      }
                      mosaicRefreshedAspect.remove();
                      _this.rastersGrid.clearSelection();
                      _this.rastersGrid.select(_this.rastersGrid.row(row.data.rasterId));
                      return selectAspect = aspect.after(_this.rastersGrid.on("dgrid-select", function() {
                        var _base;

                        if (selectAspect.done) {
                          return;
                        } else {
                          selectAspect.done = true;
                        }
                        selectAspect.remove();
                        return typeof (_base = row.data).callback === "function" ? _base.callback() : void 0;
                      }));
                    });
                  },
                  error: function(_arg2) {
                    var message;

                    message = _arg2.message;
                    return console.error(message);
                  }
                }, {
                  usePost: true
                });
              } else {
                return typeof (_base = row.data).callback === "function" ? _base.callback() : void 0;
              }
            };
            popup.open({
              popup: _this.asyncTaskDetailsPopup,
              around: row.element,
              orient: ["before-centered", "after-centered", "above-centered"]
            });
            return _this.asyncTaskDetailsPopup.focus();
          });
          connect(document, "onkeydown", function(e) {
            if (document.activeElement.tagName.toLowerCase() === "input" && document.activeElement.type.toLowerCase() === "text") {
              return;
            }
            if (e.which === 82) {
              _this.toggleRasterLayerButton.set("checked", !_this.toggleRasterLayerButton.checked);
              return _this.toggleRasterLayer(_this.toggleRasterLayerButton.checked);
            } else if (e.which === 70) {
              _this.toggleFootprintsButton.set("checked", !_this.toggleFootprintsButton.checked);
              return _this.toggleFootprints(_this.toggleFootprintsButton.checked);
            }
          });
          _this.socket = io.connect();
          _this.socket.on("connect", function() {
            return _this.socket.emit("getWIPs", function(wips) {
              return _this.wipRasters = wips;
            });
          });
          _this.socket.on("addedWIP", function(rasterId) {
            _this.wipRasters.push(rasterId);
            return _this.refreshRasterMeta(rasterId, function() {
              if (domStyle.get(_this.selectRasterContainer.domNode, "display") === "block") {
                return _this.refreshMosaicRule();
              }
            });
          });
          _this.socket.on("removedWIP", function(rasterId) {
            _this.wipRasters = _this.wipRasters.filter(function(x) {
              return x !== rasterId;
            });
            return _this.refreshRasterMeta(rasterId, function() {
              if (domStyle.get(_this.selectRasterContainer.domNode, "display") === "block") {
                return _this.refreshMosaicRule();
              }
            });
          });
          _this.socket.on("modifiedRaster", function(rasterId) {
            return _this.refreshRasterMeta(rasterId, function() {
              if (domStyle.get(_this.selectRasterContainer.domNode, "display") === "block") {
                return _this.refreshMosaicRule();
              }
            });
          });
          return window.self = _this;
        });
      },
      refreshMosaicRule: function(callback) {
        var raster, updateEvent,
          _this = this;

        this.imageServiceLayer.setMosaicRule(extend(new MosaicRule, {
          method: MosaicRule.METHOD_LOCKRASTER,
          lockRasterIds: (function() {
            var raster, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _ref3, _results;

            _ref = _this.rasters.data;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              raster = _ref[_i];
              raster.footprint.setSymbol(_this.footprintSymbol);
            }
            if ((_ref1 = _this.rasters.get(_this.currentId)) != null) {
              _ref1.footprint.setSymbol(_this.selectedFootprintSymbol);
            }
            _this.footprintsLayer.clear();
            if (domStyle.get(_this.selectRasterContainer.domNode, "display") === "block" || (_this.currentId == null)) {
              _this.imageServiceLayer.setVisibility(((function() {
                var _j, _len1, _ref2, _results;

                _ref2 = this.rasters.data;
                _results = [];
                for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
                  raster = _ref2[_j];
                  if (raster.display) {
                    _results.push(raster);
                  }
                }
                return _results;
              }).call(_this)).length > 0);
              _ref2 = _this.rasters.data;
              for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
                raster = _ref2[_j];
                if (raster.display) {
                  _this.footprintsLayer.add(raster.footprint);
                }
              }
              _ref3 = _this.rasters.data;
              _results = [];
              for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
                raster = _ref3[_k];
                if (raster.display) {
                  _results.push(raster.rasterId);
                }
              }
              return _results;
            } else {
              _this.imageServiceLayer.setVisibility(true);
              _this.footprintsLayer.add(_this.rasters.get(_this.currentId).footprint);
              return [_this.currentId];
            }
          })()
        }));
        if (!(domStyle.get(this.selectRasterContainer.domNode, "display") === "block" || (this.currentId == null)) || ((function() {
          var _i, _len, _ref, _results;

          _ref = this.rasters.data;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            raster = _ref[_i];
            if (raster.display) {
              _results.push(raster);
            }
          }
          return _results;
        }).call(this)).length > 0) {
          domStyle.set(this.loadingGif, "display", "block");
          return updateEvent = connect(this.imageServiceLayer, "onUpdateEnd", function() {
            disconnect(updateEvent);
            domStyle.set(_this.loadingGif, "display", "none");
            return typeof callback === "function" ? callback() : void 0;
          });
        }
      },
      loadRastersList: function(callback) {
        var georefStatus,
          _this = this;

        if (this.map.extent == null) {
          return typeof callback === "function" ? callback() : void 0;
        }
        georefStatus = this.currentGeorefStatus();
        return request({
          url: this.imageServiceUrl + "/query",
          content: {
            f: "json",
            where: (function() {
              var wipRs;

              wipRs = _this.wipRasters.length > 0 ? _this.wipRasters : ["null"];
              if (georefStatus !== 3) {
                return "georefStatus = " + georefStatus + (georefStatus === 0 ? " OR georefStatus IS NULL" : "") + " AND OBJECTID NOT IN (" + (wipRs.join(", ")) + ")";
              } else {
                return "OBJECTID IN (" + (wipRs.join(", ")) + ")";
              }
            })(),
            outFields: "OBJECTID, Name, GeoRefStatus",
            geometry: georefStatus !== 1 && (this.map.extent != null) ? JSON.stringify(this.map.extent.toJson()) : void 0,
            geometryType: "esriGeometryEnvelope",
            spatialRel: "esriSpatialRelIntersects"
          },
          handlesAs: "json",
          load: function(_arg1) {
            var feature, features, oldId, raster, thisRaster, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3, _ref4;

            features = _arg1.features;
            _this.footprintsLayer.clear();
            _ref = (function(func, args, ctor) {
              ctor.prototype = func.prototype;
              var child = new ctor, result = func.apply(child, args);
              return Object(result) === result ? result : child;
            })(Array, _this.rasters.data, function(){});
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              raster = _ref[_i];
              delete _this.rastersArchive[raster.rasterId];
              if (!raster.display || (raster.tiepoints != null)) {
                _this.rastersArchive[raster.rasterId] = raster;
              }
              _this.rasters.remove(raster.rasterId);
            }
            for (_j = 0, _len1 = features.length; _j < _len1; _j++) {
              feature = features[_j];
              if (!(feature.attributes.Name !== "World_Imagery")) {
                continue;
              }
              if ((thisRaster = _this.rastersArchive[feature.attributes.OBJECTID]) == null) {
                thisRaster = _this.rastersArchive[feature.attributes.OBJECTID] = {
                  rasterId: feature.attributes.OBJECTID,
                  name: feature.attributes.Name,
                  spatialReference: new SpatialReference(feature.geometry.spatialReference),
                  display: true,
                  footprint: new Graphic(new Polygon(feature.geometry), _this.currentId === feature.attributes.OBJECTID ? _this.selectedFootprintSymbol : _this.footprintSymbol)
                };
              } else {
                thisRaster.footprint.setGeometry(new Polygon(feature.geometry));
              }
              thisRaster.georefStatus = feature.attributes.GeoRefStatus;
              _this.rasters.put(thisRaster);
            }
            if (domStyle.get(_this.selectRasterContainer.domNode, "display") === "block") {
              _ref1 = _this.rasters.data;
              for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
                raster = _ref1[_k];
                if (raster.display) {
                  _this.footprintsLayer.add(raster.footprint);
                }
              }
            } else {
              _ref2 = _this.rasters.data;
              for (_l = 0, _len3 = _ref2.length; _l < _len3; _l++) {
                raster = _ref2[_l];
                if (raster.footprint.symbol === _this.selectedFootprintSymbol) {
                  _this.footprintsLayer.add(raster.footprint);
                }
              }
            }
            _this.rastersGrid.set("store", _this.rasters);
            if (typeof callback === "function") {
              callback();
            }
            _this.rastersGrid.clearSelection();
            if (_this.currentId != null) {
              if (_this.rasters.get(_this.currentId) != null) {
                return _this.rastersGrid.select(_this.currentId);
              } else {
                if ((_this.currentId != null) && !((_ref3 = _this.rastersArchive[_this.currentId]) != null ? (_ref4 = _ref3.tiepoints) != null ? _ref4.data.length : void 0 : void 0) > 0) {
                  oldId = _this.currentId;
                  _this.socket.emit("removeWIP", oldId, function(_arg2) {
                    var success;

                    success = _arg2.success;
                  });
                }
                return delete _this.currentId;
              }
            }
          },
          error: function(_arg1) {
            var message;

            message = _arg1.message;
            return console.error(message);
          }
        }, {
          usePost: true
        });
      },
      applyTransform: function(_arg1, callback) {
        var geodataTransform, gotoLocation, point, polynomialOrder, tiePoints,
          _this = this;

        tiePoints = _arg1.tiePoints, gotoLocation = _arg1.gotoLocation, geodataTransform = _arg1.geodataTransform, polynomialOrder = _arg1.polynomialOrder;
        if (gotoLocation == null) {
          gotoLocation = true;
        }
        if (geodataTransform == null) {
          geodataTransform = "Polynomial";
        }
        if (polynomialOrder == null) {
          polynomialOrder = 1;
        }
        return request({
          url: this.imageServiceUrl + "/update",
          content: {
            f: "json",
            rasterId: this.currentId,
            geodataTransforms: JSON.stringify([
              {
                geodataTransform: geodataTransform,
                geodataTransformArguments: {
                  sourcePoints: (function() {
                    var _i, _len, _ref, _results;

                    _ref = tiePoints.sourcePoints;
                    _results = [];
                    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                      point = _ref[_i];
                      _results.push({
                        x: point.x,
                        y: point.y
                      });
                    }
                    return _results;
                  })(),
                  targetPoints: (function() {
                    var _i, _len, _ref, _results;

                    _ref = tiePoints.targetPoints;
                    _results = [];
                    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                      point = _ref[_i];
                      _results.push({
                        x: point.x,
                        y: point.y
                      });
                    }
                    return _results;
                  })(),
                  polynomialOrder: geodataTransform === "Polynomial" ? polynomialOrder : void 0,
                  spatialReference: tiePoints.sourcePoints[0].spatialReference
                }
              }
            ]),
            attributes: JSON.stringify({
              GeoRefStatus: 2
            })
          },
          handleAs: "json",
          load: function() {
            var selectedRow, task, _i, _len, _ref;

            _ref = _this.asyncResults.data.filter(function(x) {
              var _ref;

              return x.rasterId === _this.currentId && ((_ref = x.task) === "Compute Tiepoints" || _ref === "Apply Transform (Tiepoints)");
            });
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              task = _ref[_i];
              delete task.callback;
            }
            selectedRow = _this.rasters.get(_this.currentId);
            _this.map.setExtent(gotoLocation ? selectedRow.footprint.geometry.getExtent() : _this.map.extent);
            _this.socket.emit("modifiedRaster", _this.currentId);
            return typeof callback === "function" ? callback() : void 0;
          },
          error: function(_arg2) {
            var message;

            message = _arg2.message;
            return console.error(message);
          }
        }, {
          usePost: true
        });
      },
      computeTiePoints: function(callback) {
        var _this = this;

        return request({
          url: this.imageServiceUrl + "/computeTiePoints",
          content: {
            f: "json",
            rasterId: this.currentId,
            geodataTransforms: JSON.stringify([
              {
                geodataTransform: "Identity",
                geodataTransformArguments: {
                  spatialReference: this.rasters.data.filter(function(x) {
                    return x.rasterId === _this.currentId;
                  })[0].spatialReference
                }
              }
            ])
          },
          handleAs: "json",
          timeout: 600000,
          load: function(response) {
            return typeof callback === "function" ? callback(response) : void 0;
          },
          error: function(error) {
            console.error(error.message);
            return typeof callback === "function" ? callback({
              error: error
            }) : void 0;
          }
        }, {
          usePost: true
        });
      },
      toggleRasterLayer: function(state) {
        return this.imageServiceLayer.setOpacity(state ? 1 : 0);
      },
      toggleFootprints: function(state) {
        return this.footprintsLayer.setOpacity(state ? 1 : 0);
      },
      startEditTiepoints: function() {
        var container, containers, display, selectedRow, tiepoint, _i, _j, _len, _len1, _ref, _ref1, _ref2;

        if (this.currentId == null) {
          return this.showRasterNotSelectedDialog();
        }
        selectedRow = this.rasters.get(this.currentId);
        this.tiepointsGrid.set("store", (_ref = selectedRow.tiepoints) != null ? _ref : selectedRow.tiepoints = new Observable(new Memory({
          idProperty: "id"
        })));
        _ref1 = selectedRow.tiepoints.data;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          tiepoint = _ref1[_i];
          this.tiepointsLayer.add(tiepoint.sourcePoint);
          this.tiepointsLayer.add(tiepoint.targetPoint);
        }
        this.applyManualTransform_RefreshButtons();
        _ref2 = {
          none: [this.selectRasterContainer, this.tasksContainer, this.asyncResultsContainer],
          block: [this.editTiepointsContainer]
        };
        for (display in _ref2) {
          containers = _ref2[display];
          for (_j = 0, _len1 = containers.length; _j < _len1; _j++) {
            container = containers[_j];
            domStyle.set(container.domNode, "display", display);
          }
        }
        return this.refreshMosaicRule();
      },
      collectComputedTiepoints: function() {
        var _this = this;

        this.confirmActionPopupContinueEvent = function() {
          var asyncTask;

          _this.confirmActionPopupClose();
          _this.asyncResults.put(asyncTask = {
            resultId: (Math.max.apply(Math, _this.asyncResults.data.map(function(x) {
              return x.resultId;
            }).concat(0))) + 1,
            task: "Compute Tiepoints",
            rasterId: _this.currentId,
            status: "Pending",
            startTime: (new Date).toLocaleString()
          });
          if (domStyle.get(_this.selectRasterContainer.domNode, "display") === "block") {
            domStyle.set(_this.asyncResultsContainer.domNode, "display", "block");
          }
          _this.asyncResultsGrid.select(asyncTask);
          _this.closeEditTiepoints();
          return _this.computeTiePoints(function(_arg1) {
            var error, i, newId, selectedRow, sourcePoint, targetPoint, tiePoints, _i, _ref;

            tiePoints = _arg1.tiePoints, error = _arg1.error;
            if (error != null) {
              extend(asyncTask, {
                status: "Failed",
                endTime: (new Date).toLocaleString()
              });
              return _this.asyncResults.notify(asyncTask, asyncTask.resultId);
            }
            selectedRow = _this.rastersArchive[asyncTask.rasterId];
            newId = Math.max.apply(Math, selectedRow.tiepoints.data.map(function(x) {
              return x.id;
            }).concat(0)) + 1;
            for (i = _i = 0, _ref = tiePoints.sourcePoints.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
              selectedRow.tiepoints.put({
                id: newId + i,
                sourcePoint: sourcePoint = new Graphic(new Point(tiePoints.sourcePoints[i]), _this.sourceSymbol),
                targetPoint: targetPoint = new Graphic(new Point(tiePoints.targetPoints[i]), _this.targetSymbol),
                original: {
                  sourcePoint: new Point(tiePoints.sourcePoints[i]),
                  targetPoint: new Point(tiePoints.targetPoints[i])
                }
              });
              if (_this.rastersGrid.isSelected(selectedRow.rasterId) && domStyle.get(_this.editTiepointsContainer.domNode, "display") === "block") {
                _this.tiepointsLayer.add(sourcePoint);
                _this.tiepointsLayer.add(targetPoint);
              }
            }
            if (_this.rastersGrid.isSelected(selectedRow.rasterId) && domStyle.get(_this.editTiepointsContainer.domNode, "display") === "block") {
              _this.applyManualTransform_RefreshButtons();
            }
            extend(asyncTask, {
              status: "Completed",
              endTime: (new Date).toLocaleString(),
              callback: function() {
                return _this.startEditTiepoints();
              },
              callbackLabel: "Edit Tiepoints"
            });
            return _this.asyncResults.notify(asyncTask, asyncTask.resultId);
          });
        };
        popup.open({
          popup: this.confirmActionPopup,
          around: this.collectComputedTiepointsButton.domNode,
          orient: ["before-centered", "after-centered", "above-centered"]
        });
        return this.confirmActionPopup.focus();
      },
      closeEditTiepoints: function() {
        var container, containers, display, _i, _len, _ref,
          _this = this;

        this.tiepointsLayer.clear();
        _ref = {
          block: [this.selectRasterContainer, this.tasksContainer],
          none: [this.editTiepointsContainer]
        };
        for (display in _ref) {
          containers = _ref[display];
          for (_i = 0, _len = containers.length; _i < _len; _i++) {
            container = containers[_i];
            domStyle.set(container.domNode, "display", display);
          }
        }
        if (this.asyncResults.data.length > 0) {
          domStyle.set(this.asyncResultsContainer.domNode, "display", "block");
        }
        return this.loadRastersList(function() {
          return _this.refreshMosaicRule();
        });
      },
      toggleTiepointsSelection: function() {
        if (this.toggleTiepointsSelectionMenuItem.label === "Clear Selection") {
          return this.tiepointsGrid.clearSelection();
        } else {
          return this.tiepointsGrid.selectAll();
        }
      },
      tiepointsContextMenuOpen: function() {
        return domStyle.set(this.resetTiepointMenuItem.domNode, "display", this.tiepointsGrid.cell(this.tiepointsContextMenu.currentTarget).row.data.original != null ? "table-row" : "none");
      },
      removeTiepoint: function() {
        var graphic, selectedRow, tiepoint, _i, _len, _ref;

        selectedRow = this.rasters.get(this.currentId);
        selectedRow.tiepoints.remove((tiepoint = this.tiepointsGrid.cell(this.tiepointsContextMenu.currentTarget).row.data).id);
        _ref = [tiepoint.sourcePoint, tiepoint.targetPoint];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          graphic = _ref[_i];
          this.tiepointsLayer.remove(graphic);
        }
        return this.applyManualTransform_RefreshButtons();
      },
      resetTiepoint: function() {
        var key, tiepoint, _i, _len, _ref, _results;

        tiepoint = this.tiepointsGrid.cell(this.tiepointsContextMenu.currentTarget).row.data;
        _ref = ["sourcePoint", "targetPoint"];
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          key = _ref[_i];
          tiepoint[key].setGeometry(tiepoint.original[key]);
          _results.push(tiepoint[key].pointChanged());
        }
        return _results;
      },
      addTiepoint: function(state) {
        var closeMouseTip, contextMenuEvent, currentState, mapDownEvent, mapDragEvent, mapUpEvent, mouseTipDownEvent, mouseTipMoveEvent, selectedRow, sourcePoint, targetPoint,
          _this = this;

        if (state) {
          selectedRow = this.rasters.get(this.currentId);
          currentState = "started";
          this.map.setMapCursor("crosshair");
          sourcePoint = null;
          targetPoint = null;
          this.mouseTip.innerHTML = "Click to place Source Point on the map.<br>Right Click to cancel.";
          mouseTipMoveEvent = connect(query("body")[0], "onmousemove", function(e) {
            domStyle.set(_this.mouseTip, "display", "block");
            domStyle.set(_this.mouseTip, "left", e.clientX + 20 + "px");
            return domStyle.set(_this.mouseTip, "top", e.clientY + 20 + "px");
          });
          mouseTipDownEvent = connect(query("body")[0], "onmousedown", function(e) {
            var point, _i, _len, _ref;

            if (_this.toggleRasterLayerButton.hovering) {
              return;
            }
            if (currentState === "placingSourcePoint") {
              return currentState = "placingSourcePoint.1";
            }
            if (currentState === "placingTargetPoint") {
              return currentState = "placingTargetPoint.1";
            }
            if (e.which !== 3) {
              if (typeof closeMouseTip === "function") {
                closeMouseTip();
              }
            }
            _ref = [sourcePoint, targetPoint];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              point = _ref[_i];
              _this.tiepointsLayer.remove(point);
            }
            if (!_this.addTiepointButton.hovering) {
              return _this.addTiepointButton.set("checked", false);
            }
          });
          mapDownEvent = connect(this.map, "onMouseDown", function(e) {
            if (e.which !== 1) {
              return;
            }
            return currentState = (function() {
              switch (currentState) {
                case "started":
                  return "placingSourcePoint";
                case "placedSourcePoint":
                  return "placingTargetPoint";
                default:
                  return currentState;
              }
            })();
          });
          mapUpEvent = connect(this.map, "onMouseUp", function(e) {
            var lastId, tiepoint;

            if (currentState === "placingSourcePoint.1") {
              currentState = "placedSourcePoint";
              sourcePoint = new Graphic(e.mapPoint, _this.sourceSymbol);
              _this.tiepointsLayer.add(sourcePoint);
              return _this.mouseTip.innerHTML = "Click to place Target Point on the map.<br>Right Click to cancel.";
            } else if (currentState === "placingTargetPoint.1") {
              currentState = "placedTargetPoint";
              targetPoint = new Graphic(e.mapPoint, _this.targetSymbol);
              _this.tiepointsLayer.add(targetPoint);
              selectedRow.tiepoints.put(tiepoint = {
                id: lastId = Math.max.apply(Math, selectedRow.tiepoints.data.map(function(x) {
                  return x.id;
                }).concat(0)) + 1,
                sourcePoint: sourcePoint,
                targetPoint: targetPoint
              });
              _this.applyManualTransform_RefreshButtons();
              closeMouseTip();
              return _this.addTiepoint(true);
            }
          });
          mapDragEvent = connect(this.map, "onMouseDrag", function(e) {
            return currentState = (function() {
              switch (currentState) {
                case "placingSourcePoint.1":
                  return "started";
                case "placingTargetPoint.1":
                  return "placingTargetPoint";
                default:
                  return currentState;
              }
            })();
          });
          contextMenuEvent = connect(query("body")[0], "oncontextmenu", function(e) {
            if (typeof closeMouseTip === "function") {
              closeMouseTip();
            }
            return e.preventDefault();
          });
          return closeMouseTip = function() {
            disconnect(mouseTipMoveEvent);
            disconnect(mouseTipDownEvent);
            disconnect(mapDownEvent);
            disconnect(mapUpEvent);
            disconnect(mapDragEvent);
            disconnect(contextMenuEvent);
            domStyle.set(_this.mouseTip, "display", "none");
            _this.mouseTip.innerHTML = "...";
            _this.map.setMapCursor("default");
            return currentState = "placedTiepoint";
          };
        }
      },
      removeSelectedTiepoints: function() {
        var bool, graphic, rowId, selectedRow, tiepoint, _i, _len, _ref, _ref1;

        selectedRow = this.rasters.get(this.currentId);
        _ref = this.tiepointsGrid.selection;
        for (rowId in _ref) {
          bool = _ref[rowId];
          if (!(bool)) {
            continue;
          }
          selectedRow.tiepoints.remove((tiepoint = this.tiepointsGrid.row(rowId).data).id);
          _ref1 = [tiepoint.sourcePoint, tiepoint.targetPoint];
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            graphic = _ref1[_i];
            this.tiepointsLayer.remove(graphic);
          }
        }
        return this.applyManualTransform_RefreshButtons();
      },
      resetSelectedTiepoints: function() {
        var bool, key, rowId, tiepoint, _ref, _results;

        _ref = this.tiepointsGrid.selection;
        _results = [];
        for (rowId in _ref) {
          bool = _ref[rowId];
          if (!(bool)) {
            continue;
          }
          tiepoint = this.tiepointsGrid.row(rowId).data;
          if (tiepoint.original == null) {
            continue;
          }
          _results.push((function() {
            var _i, _len, _ref1, _results1;

            _ref1 = ["sourcePoint", "targetPoint"];
            _results1 = [];
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
              key = _ref1[_i];
              tiepoint[key].setGeometry(tiepoint.original[key]);
              _results1.push(tiepoint[key].pointChanged());
            }
            return _results1;
          })());
        }
        return _results;
      },
      applyManualTransform_RefreshButtons: function() {
        var selectedRow;

        selectedRow = this.rasters.get(this.currentId);
        this.applyManualTransform_ProjectiveButton.set("disabled", selectedRow.tiepoints.data.length < 4);
        this.applyManualTransform_1stOrderButton.set("disabled", selectedRow.tiepoints.data.length < 3);
        this.applyManualTransform_2ndOrderButton.set("disabled", selectedRow.tiepoints.data.length < 6);
        this.applyManualTransform_3rdOrderButton.set("disabled", selectedRow.tiepoints.data.length < 10);
        this.applyManualTransform_ProjectiveTooltip.set("connectId", (selectedRow.tiepoints.data.length < 4 ? this.applyManualTransform_ProjectiveButton.domNode : void 0));
        this.applyManualTransform_1stOrderTooltip.set("connectId", (selectedRow.tiepoints.data.length < 3 ? this.applyManualTransform_1stOrderButton.domNode : void 0));
        this.applyManualTransform_2ndOrderTooltip.set("connectId", (selectedRow.tiepoints.data.length < 6 ? this.applyManualTransform_2ndOrderButton.domNode : void 0));
        return this.applyManualTransform_3rdOrderTooltip.set("connectId", (selectedRow.tiepoints.data.length < 10 ? this.applyManualTransform_3rdOrderButton.domNode : void 0));
      },
      applyManualTransform: function(_arg1) {
        var geodataTransform, polynomialOrder, selectedRow, _ref,
          _this = this;

        _ref = _arg1 != null ? _arg1 : {}, geodataTransform = _ref.geodataTransform, polynomialOrder = _ref.polynomialOrder;
        domStyle.set(this.loadingGif, "display", "block");
        selectedRow = this.rasters.get(this.currentId);
        return this.applyTransform({
          tiePoints: {
            sourcePoints: selectedRow.tiepoints.data.map(function(x) {
              return x.sourcePoint.geometry;
            }),
            targetPoints: selectedRow.tiepoints.data.map(function(x) {
              return x.targetPoint.geometry;
            })
          },
          geodataTransform: geodataTransform,
          polynomialOrder: polynomialOrder
        }, function() {
          var updateEndEvent;

          return updateEndEvent = connect(_this.imageServiceLayer, "onUpdateEnd", function() {
            var appliedTiepoints, asyncTask, tiepoint, _i, _len, _ref1;

            disconnect(updateEndEvent);
            appliedTiepoints = (function(func, args, ctor) {
              ctor.prototype = func.prototype;
              var child = new ctor, result = func.apply(child, args);
              return Object(result) === result ? result : child;
            })(Array, selectedRow.tiepoints.data, function(){});
            _this.asyncResults.put(asyncTask = {
              resultId: (Math.max.apply(Math, _this.asyncResults.data.map(function(x) {
                return x.resultId;
              }).concat(0))) + 1,
              task: "Apply Transform (Tiepoints)",
              rasterId: _this.currentId,
              status: "Completed",
              time: (new Date).toLocaleString(),
              callback: function() {
                domStyle.set(_this.loadingGif, "display", "block");
                return request({
                  url: _this.imageServiceUrl + "/update",
                  content: {
                    f: "json",
                    rasterId: _this.currentId,
                    geodataTransforms: JSON.stringify([
                      {
                        geodataTransform: "Identity",
                        geodataTransformArguments: {
                          spatialReference: selectedRow.spatialReference
                        }
                      }
                    ]),
                    geodataTransformApplyMethod: "esriGeodataTransformApplyReplace"
                  },
                  handleAs: "json",
                  load: function() {
                    var task, tiepoint, _i, _j, _len, _len1, _ref1;

                    _ref1 = _this.asyncResults.data.filter(function(x) {
                      var _ref1;

                      return x.rasterId === _this.currentId && ((_ref1 = x.task) === "Compute Tiepoints" || _ref1 === "Apply Transform (Tiepoints)");
                    });
                    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                      task = _ref1[_i];
                      delete task.callback;
                    }
                    selectedRow = _this.rasters.get(_this.currentId);
                    for (_j = 0, _len1 = appliedTiepoints.length; _j < _len1; _j++) {
                      tiepoint = appliedTiepoints[_j];
                      selectedRow.tiepoints.put(tiepoint);
                    }
                    delete asyncTask.callback;
                    _this.startEditTiepoints();
                    domStyle.set(_this.loadingGif, "display", "none");
                    return _this.socket.emit("modifiedRaster", _this.currentId);
                  },
                  error: function(_arg2) {
                    var message;

                    message = _arg2.message;
                    return console.error(message);
                  }
                }, {
                  usePost: true
                });
              },
              callbackLabel: "Redo Edit Tiepoints"
            });
            if (domStyle.get(_this.selectRasterContainer.domNode, "display") === "block") {
              domStyle.set(_this.asyncResultsContainer.domNode, "display", "block");
            }
            _this.asyncResultsGrid.select(asyncTask);
            _ref1 = selectedRow.tiepoints.data.splice(0);
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
              tiepoint = _ref1[_i];
              selectedRow.tiepoints.remove(tiepoint.id);
            }
            _this.closeEditTiepoints();
            return domStyle.set(_this.loadingGif, "display", "none");
          });
        });
      },
      applyManualTransform_Projective: function() {
        return this.applyManualTransform({
          geodataTransform: "Projective"
        });
      },
      applyManualTransform_1stOrder: function() {
        return this.applyManualTransform({
          geodataTransform: "Polynomial",
          polynomialOrder: 1
        });
      },
      applyManualTransform_2ndOrder: function() {
        return this.applyManualTransform({
          geodataTransform: "Polynomial",
          polynomialOrder: 2
        });
      },
      applyManualTransform_3rdOrder: function() {
        return this.applyManualTransform({
          geodataTransform: "Polynomial",
          polynomialOrder: 3
        });
      },
      openRoughTransform: function() {
        var container, containers, display, _i, _len, _ref;

        if (this.currentId == null) {
          return this.showRasterNotSelectedDialog();
        }
        _ref = {
          none: [this.selectRasterContainer, this.tasksContainer, this.asyncResultsContainer],
          block: [this.manualTransformContainer]
        };
        for (display in _ref) {
          containers = _ref[display];
          for (_i = 0, _len = containers.length; _i < _len; _i++) {
            container = containers[_i];
            domStyle.set(container.domNode, "display", display);
          }
        }
        return this.refreshMosaicRule();
      },
      closeRoughTransform: function() {
        var button, container, containers, display, _i, _j, _len, _len1, _ref, _ref1,
          _this = this;

        _ref = {
          block: [this.selectRasterContainer, this.tasksContainer],
          none: [this.manualTransformContainer]
        };
        for (display in _ref) {
          containers = _ref[display];
          for (_i = 0, _len = containers.length; _i < _len; _i++) {
            container = containers[_i];
            domStyle.set(container.domNode, "display", display);
          }
        }
        if (this.asyncResults.data.length > 0) {
          domStyle.set(this.asyncResultsContainer.domNode, "display", "block");
        }
        _ref1 = [this.rt_moveButton, this.rt_scaleButton, this.rt_rotateButton];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          button = _ref1[_j];
          button.set("checked", false);
        }
        return this.loadRastersList(function() {
          return _this.refreshMosaicRule();
        });
      },
      projectIfReq: function(_arg1, callback) {
        var geometries, outSR,
          _this = this;

        geometries = _arg1.geometries, outSR = _arg1.outSR;
        if (geometries.every(function(x) {
          return x.spatialReference.equals(outSR);
        })) {
          return typeof callback === "function" ? callback(geometries) : void 0;
        }
        return this.geometryService.project(extend(new ProjectParameters, {
          geometries: geometries,
          outSR: outSR
        }), function(geometries) {
          return typeof callback === "function" ? callback(geometries) : void 0;
        });
      },
      applyRoughTransform: function(argObj, callback) {
        var _this = this;

        return this.applyTransform(argObj, function() {
          return _this.refreshRasterMeta(_this.currentId, function() {
            return typeof callback === "function" ? callback() : void 0;
          });
        });
      },
      rt_fit: function() {
        var bool, rowId,
          _this = this;

        domStyle.set(this.loadingGif, "display", "block");
        return this.projectIfReq({
          geometries: ((function() {
            var _ref, _results;

            _ref = this.rastersGrid.selection;
            _results = [];
            for (rowId in _ref) {
              bool = _ref[rowId];
              if (bool) {
                _results.push(this.rastersGrid.row(rowId).data.footprint.geometry.getExtent());
              }
            }
            return _results;
          }).call(this)).concat(this.map.extent),
          outSR: this.rasters.data.filter(function(x) {
            return x.rasterId === _this.currentId;
          })[0].spatialReference
        }, function(_arg1) {
          var fromExt, mapExtent;

          fromExt = _arg1[0], mapExtent = _arg1[1];
          return _this.applyRoughTransform({
            tiePoints: {
              sourcePoints: [
                new Point({
                  x: fromExt.xmin,
                  y: fromExt.ymin,
                  spatialReference: fromExt.spatialReference
                }), new Point({
                  x: fromExt.xmin,
                  y: fromExt.ymax,
                  spatialReference: fromExt.spatialReference
                }), new Point({
                  x: fromExt.xmax,
                  y: fromExt.ymin,
                  spatialReference: fromExt.spatialReference
                })
              ],
              targetPoints: (function() {
                var aspectRatio, dest, map;

                aspectRatio = (fromExt.xmax - fromExt.xmin) / (fromExt.ymax - fromExt.ymin);
                map = {
                  width: mapExtent.getWidth(),
                  height: mapExtent.getHeight(),
                  center: mapExtent.getCenter()
                };
                dest = {
                  width: Math.min(map.width, map.height * aspectRatio),
                  height: Math.min(map.height, map.width / aspectRatio)
                };
                dest.xmin = map.center.x - dest.width / 2;
                dest.xmax = map.center.x + dest.width / 2;
                dest.ymin = map.center.y - dest.height / 2;
                dest.ymax = map.center.y + dest.height / 2;
                return [
                  {
                    x: dest.xmin,
                    y: dest.ymin
                  }, {
                    x: dest.xmin,
                    y: dest.ymax
                  }, {
                    x: dest.xmax,
                    y: dest.ymin
                  }
                ];
              })()
            },
            gotoLocation: false
          }, function() {
            var updateEndEvent;

            return updateEndEvent = connect(_this.imageServiceLayer, "onUpdateEnd", function() {
              disconnect(updateEndEvent);
              return domStyle.set(_this.loadingGif, "display", "none");
            });
          });
        });
      },
      rt_move: function(state) {
        var button, theGrid, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _results,
          _this = this;

        if (state) {
          domStyle.set(this.rtMoveContainer.domNode, "display", "block");
          _ref = [this.rt_scaleButton, this.rt_rotateButton];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            button = _ref[_i];
            button.set("checked", false);
          }
          _ref1 = [this.rtMoveFromGrid, this.rtMoveToGrid];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            theGrid = _ref1[_j];
            theGrid.set("onPointChanged", function() {
              var thePoint;

              thePoint = new Graphic(new Point({
                x: Number(theGrid.get("x")),
                y: Number(theGrid.get("y")),
                spatialReference: _this.map.spatialReference
              }), theGrid === _this.rtMoveFromGrid ? _this.sourceSymbol : _this.targetSymbol);
              _this.miscGraphicsLayer.add(thePoint);
              theGrid.set("onPointChanged", function(_arg1) {
                var point, x, y;

                x = _arg1.x, y = _arg1.y;
                point = new Point(thePoint.geometry);
                point.x = x;
                point.y = y;
                return thePoint.setGeometry(point);
              });
              thePoint.pointChanged = function() {
                return theGrid.setPoint({
                  x: thePoint.geometry.x,
                  y: thePoint.geometry.y
                });
              };
              return theGrid.graphic = thePoint;
            });
          }
          return this.rtMoveFromPick(true);
        } else {
          domStyle.set(this.rtMoveContainer.domNode, "display", "none");
          _ref2 = [this.rtMoveFromGrid, this.rtMoveToGrid];
          _results = [];
          for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
            theGrid = _ref2[_k];
            theGrid.setPoint({
              x: "",
              y: ""
            });
            theGrid.set("onPointChanged", null);
            if (theGrid.graphic != null) {
              this.miscGraphicsLayer.remove(theGrid.graphic);
            }
            _results.push(delete theGrid.graphic);
          }
          return _results;
        }
      },
      rt_moveClose: function() {
        return this.rt_moveButton.set("checked", false);
      },
      rtMovePick: function(_arg1) {
        var closeMouseTip, contextMenuEvent, currentState, mapDownEvent, mapDragEvent, mapUpEvent, mouseTipDownEvent, mouseTipMoveEvent, state, theButton, theGrid, thePoint, which,
          _this = this;

        which = _arg1.which, state = _arg1.state;
        if (state) {
          currentState = "started";
          this.map.setMapCursor("crosshair");
          thePoint = null;
          theButton = which === "from" ? this.rtMoveFromPickButton : this.rtMoveToPickButton;
          theGrid = which === "from" ? this.rtMoveFromGrid : this.rtMoveToGrid;
          this.mouseTip.innerHTML = "Click to place " + (which === "from" ? "Source" : "Target") + " Point on the map.<br>Right Click to cancel.";
          mouseTipMoveEvent = connect(query("body")[0], "onmousemove", function(e) {
            domStyle.set(_this.mouseTip, "display", "block");
            domStyle.set(_this.mouseTip, "left", e.clientX + 20 + "px");
            return domStyle.set(_this.mouseTip, "top", e.clientY + 20 + "px");
          });
          mouseTipDownEvent = connect(query("body")[0], "onmousedown", function(e) {
            if (_this.toggleRasterLayerButton.hovering) {
              return;
            }
            if (currentState === "placingPoint") {
              return currentState = "placingPoint.1";
            }
            if (e.which !== 3) {
              if (typeof closeMouseTip === "function") {
                closeMouseTip();
              }
            }
            _this.miscGraphicsLayer.remove(thePoint);
            if (!theButton.hovering) {
              return theButton.set("checked", false);
            }
          });
          mapDownEvent = connect(this.map, "onMouseDown", function(e) {
            if (e.which !== 1) {
              return;
            }
            if (currentState === "started") {
              return currentState = "placingPoint";
            }
          });
          mapUpEvent = connect(this.map, "onMouseUp", function(e) {
            if (currentState === "placingPoint.1") {
              currentState = "placedPoint";
              thePoint = new Graphic(e.mapPoint, which === "from" ? _this.sourceSymbol : _this.targetSymbol);
              if (theGrid.graphic != null) {
                _this.miscGraphicsLayer.remove(theGrid.graphic);
              }
              _this.miscGraphicsLayer.add(thePoint);
              theGrid.setPoint({
                x: e.mapPoint.x,
                y: e.mapPoint.y
              });
              theGrid.set("onPointChanged", function(_arg2) {
                var point, x, y;

                x = _arg2.x, y = _arg2.y;
                point = new Point(thePoint.geometry);
                point.x = x;
                point.y = y;
                return thePoint.setGeometry(point);
              });
              thePoint.pointChanged = function() {
                return theGrid.setPoint({
                  x: thePoint.geometry.x,
                  y: thePoint.geometry.y
                });
              };
              theGrid.graphic = thePoint;
              closeMouseTip();
              theButton.set("checked", false);
              if (theButton === _this.rtMoveFromPickButton) {
                return _this.rtMoveToPickButton.set("checked", true);
              }
            }
          });
          mapDragEvent = connect(this.map, "onMouseDrag", function(e) {
            return currentState = (function() {
              switch (currentState) {
                case "placingPoint.1":
                  return "started";
                default:
                  return currentState;
              }
            })();
          });
          contextMenuEvent = connect(query("body")[0], "oncontextmenu", function(e) {
            if (typeof closeMouseTip === "function") {
              closeMouseTip();
            }
            return e.preventDefault();
          });
          return closeMouseTip = function() {
            disconnect(mouseTipMoveEvent);
            disconnect(mouseTipDownEvent);
            disconnect(mapDownEvent);
            disconnect(mapUpEvent);
            disconnect(mapDragEvent);
            disconnect(contextMenuEvent);
            domStyle.set(_this.mouseTip, "display", "none");
            _this.mouseTip.innerHTML = "...";
            _this.map.setMapCursor("default");
            return currentState = "placedMovePoint";
          };
        }
      },
      rtMoveFromPick: function(state) {
        return this.rtMovePick({
          which: "from",
          state: state
        });
      },
      rtMoveToPick: function(state) {
        return this.rtMovePick({
          which: "to",
          state: state
        });
      },
      rt_moveTransform: function() {
        var _ref, _ref1,
          _this = this;

        domStyle.set(this.loadingGif, "display", "block");
        return this.projectIfReq({
          geometries: [new Point((_ref = this.rtMoveFromGrid.graphic) != null ? _ref.geometry : void 0), new Point((_ref1 = this.rtMoveToGrid.graphic) != null ? _ref1.geometry : void 0)],
          outSR: this.rasters.data.filter(function(x) {
            return x.rasterId === _this.currentId;
          })[0].spatialReference
        }, function(_arg1) {
          var fromPoint, offsets, point, toPoint;

          fromPoint = _arg1[0], toPoint = _arg1[1];
          return _this.applyRoughTransform({
            tiePoints: {
              sourcePoints: (function() {
                var _i, _len, _ref2, _results;

                _ref2 = [[0, 0], [10, 0], [0, 10]];
                _results = [];
                for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
                  offsets = _ref2[_i];
                  point = new Point(fromPoint);
                  point.x += offsets[0];
                  point.y += offsets[1];
                  _results.push(point);
                }
                return _results;
              })(),
              targetPoints: (function() {
                var _i, _len, _ref2, _results;

                _ref2 = [[0, 0], [10, 0], [0, 10]];
                _results = [];
                for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
                  offsets = _ref2[_i];
                  point = new Point(toPoint);
                  point.x += offsets[0];
                  point.y += offsets[1];
                  _results.push(point);
                }
                return _results;
              })()
            },
            gotoLocation: false
          }, function() {
            var updateEndEvent;

            return updateEndEvent = connect(_this.imageServiceLayer, "onUpdateEnd", function() {
              disconnect(updateEndEvent);
              _this.rt_moveClose();
              return domStyle.set(_this.loadingGif, "display", "none");
            });
          });
        });
      },
      rt_scale: function(state) {
        var button, _i, _len, _ref, _results;

        if (state) {
          domStyle.set(this.rtScaleContainer.domNode, "display", "block");
          _ref = [this.rt_moveButton, this.rt_rotateButton];
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            button = _ref[_i];
            _results.push(button.set("checked", false));
          }
          return _results;
        } else {
          domStyle.set(this.rtScaleContainer.domNode, "display", "none");
          return this.rtScaleFactorInput.value = "";
        }
      },
      rt_scaleClose: function() {
        return this.rt_scaleButton.set("checked", false);
      },
      rt_scaleTransform: function() {
        var _this = this;

        domStyle.set(this.loadingGif, "display", "block");
        return request({
          url: this.imageServiceUrl + "/query",
          content: {
            objectIds: this.currentId,
            returnGeometry: true,
            outFields: "",
            f: "json"
          },
          handleAs: "json",
          load: function(response) {
            var centerPoint, offsets, point, scaleFactor;

            scaleFactor = !isNaN(_this.rtScaleFactorInput.value) ? Number(_this.rtScaleFactorInput.value) : 1;
            centerPoint = new Polygon(response.features[0].geometry).getExtent().getCenter();
            return _this.applyRoughTransform({
              tiePoints: {
                sourcePoints: (function() {
                  var _i, _len, _ref, _results;

                  _ref = [[0, 0], [10, 0], [0, 10]];
                  _results = [];
                  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                    offsets = _ref[_i];
                    point = new Point(centerPoint);
                    point.x += offsets[0];
                    point.y += offsets[1];
                    _results.push(point);
                  }
                  return _results;
                })(),
                targetPoints: (function() {
                  var _i, _len, _ref, _results;

                  _ref = [[0, 0], [10 * scaleFactor, 0], [0, 10 * scaleFactor]];
                  _results = [];
                  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                    offsets = _ref[_i];
                    point = new Point(centerPoint);
                    point.x += offsets[0];
                    point.y += offsets[1];
                    _results.push(point);
                  }
                  return _results;
                })()
              },
              gotoLocation: false
            }, function() {
              var updateEndEvent;

              return updateEndEvent = connect(_this.imageServiceLayer, "onUpdateEnd", function() {
                disconnect(updateEndEvent);
                _this.rt_scaleClose();
                return domStyle.set(_this.loadingGif, "display", "none");
              });
            });
          },
          error: function(_arg1) {
            var message;

            message = _arg1.message;
            return console.error(message);
          }
        }, {
          usePost: true
        });
      },
      rt_rotate: function(state) {
        var button, _i, _len, _ref, _results;

        if (state) {
          domStyle.set(this.rtRotateContainer.domNode, "display", "block");
          _ref = [this.rt_moveButton, this.rt_scaleButton];
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            button = _ref[_i];
            _results.push(button.set("checked", false));
          }
          return _results;
        } else {
          domStyle.set(this.rtRotateContainer.domNode, "display", "none");
          return this.rtRotateDegreesInput.value = "";
        }
      },
      rt_rotateClose: function() {
        return this.rt_rotateButton.set("checked", false);
      },
      rt_rotateTransform: function() {
        var _this = this;

        domStyle.set(this.loadingGif, "display", "block");
        return request({
          url: this.imageServiceUrl + "/query",
          content: {
            objectIds: this.currentId,
            returnGeometry: true,
            outFields: "",
            f: "json"
          },
          handleAs: "json",
          load: function(response) {
            var PI, centerPoint, cos, offsets, point, sin, theta;

            sin = Math.sin, cos = Math.cos, PI = Math.PI;
            theta = !isNaN(_this.rtRotateDegreesInput.value) ? PI / 180 * Number(_this.rtRotateDegreesInput.value) : 0;
            centerPoint = new Polygon(response.features[0].geometry).getExtent().getCenter();
            return _this.applyRoughTransform({
              tiePoints: {
                sourcePoints: (function() {
                  var _i, _len, _ref, _results;

                  _ref = [[0, 0], [10, 0], [0, 10]];
                  _results = [];
                  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                    offsets = _ref[_i];
                    point = new Point(centerPoint);
                    point.x += offsets[0];
                    point.y += offsets[1];
                    _results.push(point);
                  }
                  return _results;
                })(),
                targetPoints: (function() {
                  var _i, _len, _ref, _results;

                  _ref = [[0, 0], [10 * cos(theta), 10 * -sin(theta)], [10 * sin(theta), 10 * cos(theta)]];
                  _results = [];
                  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                    offsets = _ref[_i];
                    point = new Point(centerPoint);
                    point.x += offsets[0];
                    point.y += offsets[1];
                    _results.push(point);
                  }
                  return _results;
                })()
              },
              gotoLocation: false
            }, function() {
              var updateEndEvent;

              return updateEndEvent = connect(_this.imageServiceLayer, "onUpdateEnd", function() {
                disconnect(updateEndEvent);
                _this.rt_rotateClose();
                return domStyle.set(_this.loadingGif, "display", "none");
              });
            });
          },
          error: function(_arg1) {
            var message;

            message = _arg1.message;
            return console.error(message);
          }
        }, {
          usePost: true
        });
      },
      showRasterNotSelectedDialog: function() {
        return this.rasterNotSelectedDialog.show();
      },
      hideRasterNotSelectedDialog: function() {
        return this.rasterNotSelectedDialog.hide();
      },
      selectBasemap: function(selectedMenuItem) {
        var layerId, menuItem, menuItems, _i, _j, _len, _len1, _ref, _results;

        menuItems = [this.selectBasemap_SatelliteButton, this.selectBasemap_HybridButton, this.selectBasemap_TopographicButton, this.selectBasemap_StreetsButton, this.selectBasemap_NaturalVueButton];
        for (_i = 0, _len = menuItems.length; _i < _len; _i++) {
          menuItem = menuItems[_i];
          if (menuItem !== selectedMenuItem) {
            query(menuItem.domNode).removeClass("bold");
          }
        }
        query(selectedMenuItem.domNode).addClass("bold");
        if (this.naturalVueServiceLayer != null) {
          this.map.removeLayer(this.naturalVueServiceLayer);
          this.naturalVueServiceLayer.suspend();
          delete this.naturalVueServiceLayer;
          _ref = this.map.basemapLayerIds;
          _results = [];
          for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
            layerId = _ref[_j];
            _results.push(this.map.getLayer(layerId).setVisibility(true));
          }
          return _results;
        }
      },
      selectBasemap_Satellite: function() {
        this.selectBasemap(this.selectBasemap_SatelliteButton);
        return this.map.setBasemap("satellite");
      },
      selectBasemap_Hybrid: function() {
        this.selectBasemap(this.selectBasemap_HybridButton);
        return this.map.setBasemap("hybrid");
      },
      selectBasemap_Topographic: function() {
        this.selectBasemap(this.selectBasemap_TopographicButton);
        return this.map.setBasemap("topo");
      },
      selectBasemap_Streets: function() {
        this.selectBasemap(this.selectBasemap_StreetsButton);
        return this.map.setBasemap("streets");
      },
      selectBasemap_NaturalVue: function() {
        var layerId, _i, _len, _ref, _results;

        this.selectBasemap(this.selectBasemap_NaturalVueButton);
        this.map.addLayer((this.naturalVueServiceLayer = new ArcGISTiledMapServiceLayer(this.naturalVueServiceUrl)), 1);
        _ref = this.map.basemapLayerIds;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          layerId = _ref[_i];
          _results.push(this.map.getLayer(layerId).setVisibility(false));
        }
        return _results;
      },
      atdpClose: function() {
        popup.close(this.asyncTaskDetailsPopup);
        return this.asyncResultsGrid.clearSelection();
      },
      atdpContinue: function() {
        return typeof this.atdpContinueEvent === "function" ? this.atdpContinueEvent() : void 0;
      },
      atdpRemove: function() {
        var bool, rowId, _ref;

        _ref = this.asyncResultsGrid.selection;
        for (rowId in _ref) {
          bool = _ref[rowId];
          if (bool) {
            this.asyncResults.remove(rowId);
          }
        }
        this.atdpClose();
        if (this.asyncResults.data.length === 0) {
          return domStyle.set(this.asyncResultsContainer.domNode, "display", "none");
        }
      },
      confirmActionPopupClose: function() {
        return popup.close(this.confirmActionPopup);
      },
      confirmActionPopupContinue: function() {
        return typeof this.confirmActionPopupContinueEvent === "function" ? this.confirmActionPopupContinueEvent() : void 0;
      },
      setImageFormat: function(selectedMenuItem) {
        var menuItem, menuItems, _i, _len;

        menuItems = [this.setImageFormat_JPGPNGButton, this.setImageFormat_JPGButton];
        for (_i = 0, _len = menuItems.length; _i < _len; _i++) {
          menuItem = menuItems[_i];
          if (menuItem !== selectedMenuItem) {
            query(menuItem.domNode).removeClass("bold");
          }
        }
        return query(selectedMenuItem.domNode).addClass("bold");
      },
      setImageFormat_JPGPNG: function() {
        this.setImageFormat(this.setImageFormat_JPGPNGButton);
        return this.imageServiceLayer.setImageFormat("jpgpng");
      },
      setImageFormat_JPG: function() {
        this.setImageFormat(this.setImageFormat_JPGButton);
        return this.imageServiceLayer.setImageFormat("jpg");
      },
      rastersDisplay_enableAll: function() {
        var raster, _i, _len, _ref;

        _ref = this.rasters.data;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          raster = _ref[_i];
          raster.display = true;
          this.rasters.notify(raster, raster.rasterId);
        }
        if (this.currentId != null) {
          this.rastersGrid.select(this.currentId);
        }
        return this.refreshMosaicRule();
      },
      rastersDisplay_disableAll: function() {
        var raster, _i, _len, _ref;

        _ref = this.rasters.data;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          raster = _ref[_i];
          raster.display = false;
          this.rasters.notify(raster, raster.rasterId);
        }
        if (this.currentId != null) {
          this.rastersGrid.select(this.currentId);
        }
        return this.refreshMosaicRule();
      },
      importTiepoints: function() {
        var changeEvent, ipElement, reader,
          _this = this;

        ipElement = document.createElement("input");
        ipElement.type = "file";
        ipElement.accept = "text/plain";
        ipElement.click();
        reader = new FileReader;
        changeEvent = connect(ipElement, "onchange", function(event) {
          console.log(this.files);
          disconnect(changeEvent);
          return reader.readAsText(this.files[0]);
        });
        return reader.onload = function(_arg1) {
          var i, newId, result, selectedRow, sourcePoint, targetPoint, tiepoints, _i, _ref;

          result = _arg1.target.result;
          selectedRow = _this.rasters.get(_this.currentId);
          newId = Math.max.apply(Math, selectedRow.tiepoints.data.map(function(x) {
            return x.id;
          }).concat(0)) + 1;
          tiepoints = result.match(/^.+$/gm).map(function(x) {
            var arr;

            arr = x.split(/\t/g).map(function(x) {
              return Number(x);
            });
            return {
              sourcePoint: {
                x: arr[0],
                y: arr[1],
                spatialReference: _this.map.spatialReference
              },
              targetPoint: {
                x: arr[2],
                y: arr[3],
                spatialReference: _this.map.spatialReference
              }
            };
          });
          for (i = _i = 0, _ref = tiepoints.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
            selectedRow.tiepoints.put({
              id: newId + i,
              sourcePoint: sourcePoint = new Graphic(new Point(tiepoints[i].sourcePoint), _this.sourceSymbol),
              targetPoint: targetPoint = new Graphic(new Point(tiepoints[i].targetPoint), _this.targetSymbol),
              original: {
                sourcePoint: new Point(tiepoints[i].sourcePoint),
                targetPoint: new Point(tiepoints[i].targetPoint)
              }
            }, _this.tiepointsLayer.add(sourcePoint), _this.tiepointsLayer.add(targetPoint));
          }
          if (_this.rastersGrid.isSelected(selectedRow.rasterId) && domStyle.get(_this.editTiepointsContainer.domNode, "display") === "block") {
            return _this.applyManualTransform_RefreshButtons();
          }
        };
      },
      exportTiepoints: function() {
        var blob, selectedRow,
          _this = this;

        selectedRow = this.rasters.get(this.currentId);
        blob = new Blob(["Hello, world!"], {
          type: "text/plain;charset=utf-8"
        });
        return saveAs(new Blob([
          selectedRow.tiepoints.data.map(function(x) {
            return [x.sourcePoint.geometry.x, x.sourcePoint.geometry.y, x.targetPoint.geometry.x, x.targetPoint.geometry.y].join("\t");
          }).join("\r\n")
        ]), "tiepoints_raster" + selectedRow.rasterId + ".txt");
      },
      refreshRasterMeta: function(rasterId, callback) {
        var _this = this;

        return request({
          url: this.imageServiceUrl + "/query",
          content: {
            f: "json",
            where: "OBJECTID = " + rasterId,
            outFields: "OBJECTID, Name, GeoRefStatus"
          },
          handlesAs: "json",
          load: function(_arg1) {
            var feature, footprintGeometry, georefStatus;

            feature = _arg1.features[0];
            georefStatus = _this.currentGeorefStatus();
            footprintGeometry = new Polygon(feature.geometry);
            if (__indexOf.call(_this.wipRasters, rasterId) >= 0) {
              feature.attributes.GeoRefStatus = 3;
            }
            if (!((_this.rastersArchive[rasterId] != null) || (georefStatus === feature.attributes.GeoRefStatus && (georefStatus === 1 || _this.map.extent.intersects(footprintGeometry))))) {
              return typeof callback === "function" ? callback() : void 0;
            }
            if (_this.rastersArchive[rasterId] != null) {
              _this.rastersArchive[rasterId].footprint.setGeometry(footprintGeometry);
            } else {
              _this.rastersArchive[rasterId] = {
                rasterId: feature.attributes.OBJECTID,
                name: feature.attributes.Name,
                spatialReference: new SpatialReference(feature.geometry.spatialReference),
                display: true,
                footprint: new Graphic(footprintGeometry, _this.currentId === feature.attributes.OBJECTID ? _this.selectedFootprintSymbol : _this.footprintSymbol)
              };
            }
            _this.rastersArchive[rasterId].georefStatus = feature.attributes.GeoRefStatus;
            if (georefStatus === feature.attributes.GeoRefStatus && (georefStatus === 1 || _this.map.extent.intersects(footprintGeometry))) {
              _this.rasters.put(_this.rastersArchive[rasterId]);
            } else {
              _this.rasters.remove(rasterId);
            }
            return typeof callback === "function" ? callback() : void 0;
          },
          error: function(_arg1) {
            var message;

            message = _arg1.message;
            return console.error(message);
          }
        }, {
          usePost: true
        });
      },
      currentGeorefStatus: function() {
        if (this.georefStatus_CompleteButton.domNode.classList.contains("bold")) {
          return 0;
        } else if (this.georefStatus_FalseButton.domNode.classList.contains("bold")) {
          return 1;
        } else if (this.georefStatus_PartialButton.domNode.classList.contains("bold")) {
          return 2;
        } else if (this.georefStatus_WIPButton.domNode.classList.contains("bold")) {
          return 3;
        }
      },
      georefStatus: function(selectedMenuItem) {
        var button, menuItem, menuItems, _i, _j, _len, _len1, _ref,
          _this = this;

        menuItems = [this.georefStatus_CompleteButton, this.georefStatus_FalseButton, this.georefStatus_PartialButton, this.georefStatus_WIPButton];
        for (_i = 0, _len = menuItems.length; _i < _len; _i++) {
          menuItem = menuItems[_i];
          if (menuItem !== selectedMenuItem) {
            query(menuItem.domNode).removeClass("bold");
          }
        }
        query(selectedMenuItem.domNode).addClass("bold");
        this.georefStatusDropButton.set("label", "Filter: " + selectedMenuItem.label);
        this.markGeoreferencedButton.set("disabled", selectedMenuItem === this.georefStatus_CompleteButton || selectedMenuItem === this.georefStatus_WIPButton);
        _ref = [this.openRoughTransformButton, this.startEditTiepointsButton];
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          button = _ref[_j];
          button.set("disabled", selectedMenuItem === this.georefStatus_WIPButton);
        }
        return this.loadRastersList(function() {
          return _this.refreshMosaicRule();
        });
      },
      georefStatus_Complete: function() {
        return this.georefStatus(this.georefStatus_CompleteButton);
      },
      georefStatus_False: function() {
        return this.georefStatus(this.georefStatus_FalseButton);
      },
      georefStatus_Partial: function() {
        return this.georefStatus(this.georefStatus_PartialButton);
      },
      georefStatus_WIP: function() {
        return this.georefStatus(this.georefStatus_WIPButton);
      },
      markGeoreferenced: function() {
        var _this = this;

        if (this.currentId == null) {
          return this.showRasterNotSelectedDialog();
        }
        return request({
          url: this.imageServiceUrl + "/update",
          content: {
            f: "json",
            rasterId: this.currentId,
            attributes: JSON.stringify({
              GeoRefStatus: 0
            })
          },
          handleAs: "json",
          load: function() {
            _this.loadRastersList(function() {
              return _this.refreshMosaicRule();
            });
            return _this.socket.emit("modifiedRaster", _this.currentId);
          },
          error: function(_arg1) {
            var message;

            message = _arg1.message;
            return console.error(message);
          }
        }, {
          usePost: true
        });
      }
    });
  });
})();
